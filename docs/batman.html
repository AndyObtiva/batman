<!doctype html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>batman.js | documentation</title>

  <script src="http://use.typekit.com/kek3ffx.js"></script>
  <script>try{Typekit.load();}catch(e){}</script>
  <link href="http://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet" type="text/css">
  <link href="css/style.css" media="screen" rel="stylesheet" type="text/css" />

  <meta name="viewport" content="width=device-width">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>

  <div id="top" class="container clearfix">

    <a class="to-top" id="fixed-goto-top" href="#top">Top</a>

    <!-- Left Navigation -->
    <div class="sidebar">

      <input id="quick-search" type="search" placeholder="Search">

      <nav>
        <ul id="table-of-contents" class="nav-list">
            <li><a href="#" class=""></a>
<ul>
  <li ><a href="#batman-js" class="">batman.js</a>
<ul>
  <li ><a href="#batman-js-its-got" class="">It&#39;s got:</a>
<ul>
  <li ><a href="#batman-js-its-got-platforms" class="">Platforms</a>
</li>
</ul>
</li>
  <li ><a href="#batman-js-installation" class="">Installation</a>
<ul>
  <li ><a href="#batman-js-installation-standalone-browser-version" class="">Standalone Browser Version</a>
</li>
  <li ><a href="#batman-js-installation-node-js" class="">node.js</a>
</li>
</ul>
</li>
  <li ><a href="#batman-js-architecture" class="">Architecture</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-helpers" class="class">Batman Helpers</a>
<ul>
  <li class="searchable"><a href="#batman-helpers-container" class="class-function">container</a>
</li>
  <li class="searchable"><a href="#batman-helpers-typeof" class="class-function">typeOf(object)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-mixin" class="class-function">mixin(subject, objects...)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-unmixin" class="class-function">unmixin(subject, objects...)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-ischildof" class="class-function">isChildOf(parent, child)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-setimmediate" class="class-function">setImmediate(callback)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-clearimmediate" class="class-function">clearImmediate(handle)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-foreach" class="class-function">forEach(iterable, iterator[, context])</a>
</li>
  <li class="searchable"><a href="#batman-helpers-objecthaskey" class="class-function">objectHasKey(object, key)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-contains" class="class-function">contains(object, item)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-get" class="class-function">get(object, key)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-escapehtml" class="class-function">escapeHTML(string)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-helpers" class="class">Batman.helpers</a>
<ul>
  <li class="searchable"><a href="#batman-helpers-ordinalize" class="class-function">ordinalize(value)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-singularize" class="class-function">singularize(pluralString)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-pluralize" class="class-function">pluralize(singularString)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-camelize" class="class-function">camelize(string, [lowercaseFirstLetter])</a>
</li>
  <li class="searchable"><a href="#batman-helpers-underscore" class="class-function">underscore(string)</a>
</li>
  <li class="searchable"><a href="#batman-helpers-capitalize" class="class-function">capitalize(string)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-eventemitter" class="class">Batman.EventEmitter</a>
<ul>
  <li class="searchable"><a href="#batman-eventemitter-on" class="class-function">on(key, handler)</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-fire" class="class-function">fire(key, arguments...)</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-hasevent" class="class-function">hasEvent(key)</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-oneshot" class="class-function">oneShot</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-prevent" class="class-function">prevent(key)</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-allow" class="class-function">allow(key)</a>
</li>
  <li class="searchable"><a href="#batman-eventemitter-allowandfire" class="class-function">allowAndFire(key)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-observable" class="class">Batman.Observable</a>
<ul>
  <li class="searchable"><a href="#batman-observable-get" class="class-function">get(keypath)</a>
</li>
  <li class="searchable"><a href="#batman-observable-set" class="class-function">set(keypath, newValue)</a>
</li>
  <li class="searchable"><a href="#batman-observable-unset" class="class-function">unset(keypath)</a>
</li>
  <li class="searchable"><a href="#batman-observable-observe" class="class-function">observe(key, observerCallback)</a>
</li>
  <li class="searchable"><a href="#batman-observable-observeandfire" class="class-function">observeAndFire(key, observerCallback)</a>
</li>
  <li class="searchable"><a href="#batman-observable-forget" class="class-function">forget([key [, observerCallback]])</a>
</li>
  <li class="searchable"><a href="#batman-observable-getorset" class="class-function">getOrSet(keypath, valueFunction)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-object" class="class">Batman.Object</a>
<ul>
  <li class="searchable"><a href="#batman-object-accessor" class="class-function">@accessor([keys...], objectOrFunction)</a>
<ul>
  <li ><a href="#batman-object-accessor-arguments" class="">Arguments</a>
</li>
  <li ><a href="#batman-object-accessor-uses" class="">Uses</a>
</li>
  <li ><a href="#batman-object-accessor-caveats" class="">Caveats</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-object-classaccessor" class="class-function">@classAccessor([keys...], objectOrFunction)</a>
</li>
  <li class="searchable"><a href="#batman-object-mixin" class="class-function">@mixin(objects...)</a>
</li>
  <li class="searchable"><a href="#batman-object-classmixin" class="class-function">@classMixin(objects...)</a>
</li>
  <li class="searchable"><a href="#batman-object-observeall" class="class-function">@observeAll(key, callback)</a>
</li>
  <li class="searchable"><a href="#batman-object-constructor" class="class-function">constructor(objects...)</a>
</li>
  <li class="searchable"><a href="#batman-object-tojson" class="class-function">toJSON()</a>
</li>
  <li class="searchable"><a href="#batman-object-hashkey" class="class-function">hashKey()</a>
</li>
  <li class="searchable"><a href="#batman-object-accessor" class="class-function">accessor([keys...], objectOrFunction)</a>
</li>
  <li class="searchable"><a href="#batman-object-mixin" class="class-function">mixin(objects...)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-simpleset" class="class">Batman.SimpleSet</a>
<ul>
  <li class="searchable"><a href="#batman-simpleset-simpleset-vs-set" class="">SimpleSet vs Set</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-constructor" class="class-function">constructor(items...)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-length" class="class-function">length</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-has" class="class-function">has(item)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-add" class="class-function">add(items...)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-remove" class="class-function">remove(items...)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-find" class="class-function">find(testFunction)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-foreach" class="class-function">forEach(iteratorFunction[, context])</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-isempty" class="class-function">isEmpty()</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-clear" class="class-function">clear()</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-replace" class="class-function">replace(collection)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-toarray" class="class-function">toArray()</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-merge" class="class-function">merge(collections...)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-indexedby" class="class-function">indexedBy(key)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-indexedbyunique" class="class-function">indexedByUnique(key)</a>
</li>
  <li class="searchable"><a href="#batman-simpleset-sortedby" class="class-function">sortedBy(key)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-set" class="class">Batman.Set</a>
<ul>
  <li class="searchable"><a href="#batman-set-simpleset-vs-set" class="">SimpleSet vs Set</a>
</li>
  <li class="searchable"><a href="#batman-set-constructor" class="class-function">constructor(items...)</a>
</li>
  <li class="searchable"><a href="#batman-set-length" class="class-function">length</a>
</li>
  <li class="searchable"><a href="#batman-set-isempty" class="class-function">isEmpty</a>
</li>
  <li class="searchable"><a href="#batman-set-toarray" class="class-function">toArray</a>
</li>
  <li class="searchable"><a href="#batman-set-has" class="class-function">has(item)</a>
</li>
  <li class="searchable"><a href="#batman-set-add" class="class-function">add(items...)</a>
</li>
  <li class="searchable"><a href="#batman-set-remove" class="class-function">remove(items...)</a>
</li>
  <li class="searchable"><a href="#batman-set-find" class="class-function">find(testFunction)</a>
</li>
  <li class="searchable"><a href="#batman-set-foreach" class="class-function">forEach(iteratorFunction[, context])</a>
</li>
  <li class="searchable"><a href="#batman-set-isempty" class="class-function">isEmpty()</a>
</li>
  <li class="searchable"><a href="#batman-set-clear" class="class-function">clear()</a>
</li>
  <li class="searchable"><a href="#batman-set-replace" class="class-function">replace(collection)</a>
</li>
  <li class="searchable"><a href="#batman-set-toarray" class="class-function">toArray()</a>
</li>
  <li class="searchable"><a href="#batman-set-merge" class="class-function">merge(collections...)</a>
</li>
  <li class="searchable"><a href="#batman-set-indexedby" class="class-function">indexedBy(key)</a>
</li>
  <li class="searchable"><a href="#batman-set-indexedbyunique" class="class-function">indexedByUnique(key)</a>
</li>
  <li class="searchable"><a href="#batman-set-sortedby" class="class-function">sortedBy(key)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-app" class="class">Batman.App</a>
<ul>
  <li class="searchable"><a href="#batman-app-batman-currentapp" class="class-function">Batman.currentApp</a>
</li>
  <li class="searchable"><a href="#batman-app-run" class="class-function">@run()</a>
<ul>
  <li ><a href="#batman-app-run-starting-an-application-with-domevents" class="">starting an application with DOMEvents</a>
</li>
  <li ><a href="#batman-app-run-starting-an-application-with-jquery" class="">starting an application with jQuery</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-app-stop" class="class-function">@stop()</a>
</li>
  <li class="searchable"><a href="#batman-app-routes" class="class-function">@routes</a>
</li>
  <li class="searchable"><a href="#batman-app-controllers" class="class-function">@controllers</a>
</li>
  <li class="searchable"><a href="#batman-app-layout" class="class-function">@layout</a>
</li>
  <li class="searchable"><a href="#batman-app-currentparams" class="class-function">@currentParams</a>
</li>
  <li class="searchable"><a href="#batman-app-paramsmanager" class="class-function">@paramsManager</a>
</li>
  <li class="searchable"><a href="#batman-app-paramspusher" class="class-function">@paramsPusher</a>
</li>
  <li class="searchable"><a href="#batman-app-run-class-event" class="class-function">&#39;run&#39; class event</a>
</li>
  <li class="searchable"><a href="#batman-app-ready-class-event" class="class-function">&#39;ready&#39; class event</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-app-routing" class="class">Batman.App Routing</a>
<ul>
  <li class="searchable"><a href="#batman-app-routing-resources" class="class-function">@resources</a>
</li>
  <li class="searchable"><a href="#batman-app-routing-member" class="class-function">@member</a>
</li>
  <li class="searchable"><a href="#batman-app-routing-collection" class="class-function">@collection</a>
</li>
  <li class="searchable"><a href="#batman-app-routing-route" class="class-function">@route</a>
</li>
  <li class="searchable"><a href="#batman-app-routing-root" class="class-function">@root</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-controller" class="class">Batman.Controller</a>
<ul>
  <li class="searchable"><a href="#batman-controller-controller-directory" class="class-function">Controller Directory</a>
</li>
  <li class="searchable"><a href="#batman-controller-actions" class="class-function">Actions</a>
</li>
  <li class="searchable"><a href="#batman-controller-routingkey-and-minification" class="class-function">`routingKey` and Minification</a>
</li>
  <li class="searchable"><a href="#batman-controller-beforefilter" class="class-function">@beforeFilter([options], filter)</a>
</li>
  <li class="searchable"><a href="#batman-controller-afterfilter" class="class-function">@afterFilter([options], filter)</a>
</li>
  <li class="searchable"><a href="#batman-controller-autoscrolltohash-true" class="class-function">autoScrollToHash[= true]</a>
</li>
  <li class="searchable"><a href="#batman-controller-defaultrenderyield-main" class="class-function">defaultRenderYield[= &#39;main&#39;]</a>
</li>
  <li class="searchable"><a href="#batman-controller-controller-actions" class="class-function">Controller Actions</a>
</li>
  <li class="searchable"><a href="#batman-controller-executeaction" class="class-function">executeAction</a>
</li>
  <li class="searchable"><a href="#batman-controller-render" class="class-function">render</a>
</li>
  <li class="searchable"><a href="#batman-controller-redirect" class="class-function">redirect</a>
</li>
  <li class="searchable"><a href="#batman-controller-scrolltohash" class="class-function">scrollToHash</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-model" class="class">Batman.Model</a>
<ul>
  <li class="searchable"><a href="#batman-model-the-asynchronous-nature-of-the-world" class="class-function">The Asynchronous Nature of the World</a>
</li>
  <li class="searchable"><a href="#batman-model-the-identity-map" class="class-function">The Identity Map</a>
</li>
  <li class="searchable"><a href="#batman-model-subclassing" class="class-function">Subclassing</a>
</li>
  <li class="searchable"><a href="#batman-model-storage-adapters" class="class-function">Storage Adapters</a>
</li>
  <li class="searchable"><a href="#batman-model-primarykey" class="class-function">@primaryKey</a>
</li>
  <li class="searchable"><a href="#batman-model-storagekey" class="class-function">@storageKey</a>
</li>
  <li class="searchable"><a href="#batman-model-persist" class="class-function">@persist(mechanism)</a>
</li>
  <li class="searchable"><a href="#batman-model-encode" class="class-function">@encode(keys...[, encoderObject])</a>
</li>
  <li class="searchable"><a href="#batman-model-validate" class="class-function">@validate(keys...[, options])</a>
</li>
  <li class="searchable"><a href="#batman-model-loaded" class="class-function">@loaded</a>
</li>
  <li class="searchable"><a href="#batman-model-all" class="class-function">@all</a>
</li>
  <li class="searchable"><a href="#batman-model-clear" class="class-function">@clear()</a>
</li>
  <li class="searchable"><a href="#batman-model-find" class="class-function">@find(id, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-load" class="class-function">@load(options = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-create" class="class-function">@create(attributes = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-findorcreate" class="class-function">@findOrCreate(attributes = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-id" class="class-function">id</a>
</li>
  <li class="searchable"><a href="#batman-model-dirtykeys" class="class-function">dirtyKeys</a>
</li>
  <li class="searchable"><a href="#batman-model-errors" class="class-function">errors</a>
</li>
  <li class="searchable"><a href="#batman-model-constructor" class="class-function">constructor(idOrAttributes = {})</a>
</li>
  <li class="searchable"><a href="#batman-model-isnew" class="class-function">isNew()</a>
</li>
  <li class="searchable"><a href="#batman-model-updateattributes" class="class-function">updateAttributes(attributes)</a>
</li>
  <li class="searchable"><a href="#batman-model-tostring" class="class-function">toString()</a>
</li>
  <li class="searchable"><a href="#batman-model-tojson" class="class-function">toJSON()</a>
</li>
  <li class="searchable"><a href="#batman-model-fromjson" class="class-function">fromJSON()</a>
</li>
  <li class="searchable"><a href="#batman-model-toparam" class="class-function">toParam()</a>
</li>
  <li class="searchable"><a href="#batman-model-state" class="class-function">state()</a>
</li>
  <li class="searchable"><a href="#batman-model-hasstorage" class="class-function">hasStorage()</a>
</li>
  <li class="searchable"><a href="#batman-model-load" class="class-function">load(options = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-save" class="class-function">save(options = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-destroy" class="class-function">destroy(options = {}, callback)</a>
</li>
  <li class="searchable"><a href="#batman-model-validate" class="class-function">validate(callback)</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-validationerror" class="class">Batman.ValidationError</a>
</li>
  <li class="searchable"><a href="#batman-errorsset" class="class">Batman.ErrorsSet</a>
</li>
  <li class="searchable"><a href="#batman-view" class="class">Batman.View</a>
</li>
  <li class="searchable"><a href="#what-are-views" class="class-function">What Are Views?</a>
<ul>
  <li class="searchable"><a href="#what-are-views-do-more" class="">Do More</a>
</li>
  <li class="searchable"><a href="#what-are-views-an-example" class="">An example</a>
</li>
  <li class="searchable"><a href="#what-are-views-if-you-want-to-do-something-to-a-views-html-after-rendering-add-a-ready-function-or-listen-to-an-event" class="">If you want to do something to a view&#39;s HTML after rendering, add a `ready` function, or listen to an event</a>
</li>
  <li class="searchable"><a href="#what-are-views-if-you-want-to-do-something-to-a-views-html-before-rendering-override-the-render-method" class="">If you want to do something to a view&#39;s HTML before rendering, override the `render` method.</a>
</li>
  <li class="searchable"><a href="#what-are-views-if-you-want-to-do-something-every-time-a-view-is-inserted-or-removed-from-the-dom-use-the-beforeappear-appear-beforedisappear-and-disappear-events" class="">If you want to do something every time a view is inserted or removed from the DOM, use the `beforeAppear`, `appear`, `beforeDisappear`, and `disappear` events.</a>
</li>
  <li class="searchable"><a href="#what-are-views-if-you-want-to-do-something-every-time-a-view-is-removed-for-good-from-the-dom-use-the-beforedestroy-or-destroy-events" class="">If you want to do something every time a view is removed for good from the DOM, use the `beforeDestroy` or `destroy` events.</a>
</li>
  <li class="searchable"><a href="#what-are-views-another-example" class="">Another example</a>
</li>
  <li class="searchable"><a href="#what-are-views-other-stuff" class="">Other Stuff</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-view-bindings" class="class">Batman View Bindings</a>
<ul>
  <li class="searchable"><a href="#batman-view-bindings-how-to-use-bindings" class="class-function">How to use bindings</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-binding-keypaths" class="class-function">Binding Keypaths</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-binding-contexts" class="class-function">Binding Contexts</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-keypath-filters" class="class-function">Keypath Filters</a>
<ul>
  <li ><a href="#batman-view-bindings-keypath-filters-two-way-bindings-and-filters" class="">Two Way Bindings and Filters</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-view-bindings-keypath-literals" class="class-function">Keypath Literals</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-bind" class="class-function">data-bind</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-source" class="class-function">data-source</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-target" class="class-function">data-target</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-showif-data-hideif" class="class-function">data-showif / data-hideif</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-addclass-data-removeclass" class="class-function">data-addclass / data-removeclass</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-foreach" class="class-function">data-foreach</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-formfor" class="class-function">data-formfor</a>
<ul>
  <li ><a href="#batman-view-bindings-data-formfor-automatic-validation-display" class="">Automatic Validation Display</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-context" class="class-function">data-context</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-event" class="class-function">data-event</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-route" class="class-function">data-route</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-view" class="class-function">data-view</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-partial" class="class-function">data-partial</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-mixin" class="class-function">data-mixin</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-defineview" class="class-function">data-defineview</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-renderif" class="class-function">data-renderif</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-yield" class="class-function">data-yield</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-contentfor" class="class-function">data-contentfor</a>
</li>
  <li class="searchable"><a href="#batman-view-bindings-data-replace" class="class-function">data-replace</a>
</li>
</ul>
</li>
  <li class="searchable"><a href="#batman-view-filters" class="class">Batman View Filters</a>
<ul>
  <li class="searchable"><a href="#batman-view-filters-raw" class="class-function">raw(value)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-get" class="class-function">get(value, key)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-valuekey" class="class-function">value[key]</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-equals" class="class-function">equals(left, right)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-not" class="class-function">not(value)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-matches" class="class-function">matches(value, string)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-truncate" class="class-function">truncate(value, length, end = &#39;...&#39;)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-default" class="class-function">default(value, defaultValue)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-prepend" class="class-function">prepend(value, string)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-append" class="class-function">append(value, string)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-replace" class="class-function">replace(value, searchString, replaceString[, flags])</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-downcase" class="class-function">downcase(value)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-upcase" class="class-function">upcase(value)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-pluralize" class="class-function">pluralize(value, count)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-humanize" class="class-function">humanize(string)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-join" class="class-function">join(value, separator = &#39;&#39;)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-sort" class="class-function">sort(value)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-map" class="class-function">map(iterable)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-has" class="class-function">has(iterable, item)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-first" class="class-function">first(iterable)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-meta" class="class-function">meta(value, keypath)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-interpolate" class="class-function">interpolate(string, valuesObject)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-witharguments" class="class-function">withArguments(function, curriedArguments...)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-routetoaction" class="class-function">routeToAction(model, action)</a>
</li>
  <li class="searchable"><a href="#batman-view-filters-escape" class="class-function">escape(value)</a>
</li>
</ul>
</li>
</ul>
</li>
        </ul>
      </nav>
    </div><!-- /.sidebar -->

    <!-- Content -->
    <div class="content" role="main">
      <h1 id="batman-js">batman.js</h1>
<p><a href="http://batmanjs.org/">batman.js</a> is a framework for building rich single-page browser applications. It is written in <a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a> and its API is developed with CoffeeScript in mind, but of course you can use plain old JavaScript too.

</p>
<h3 id="batman-js-its-got">It&#39;s got:</h3>
<ul>
<li>a stateful MVC architecture</li>
<li>a powerful binding system</li>
<li>routable controller actions</li>
<li>pure HTML views</li>
<li>toolchain support built on <a href="http://nodejs.org">node.js</a> and <a href="http://jashkenas.github.com/coffee-script/#cake">cake</a></li>
</ul>
<p>Batman&#39;s API is heavily inspired by <a href="http://rubyonrails.org/">Rails</a> and designed to make Rails devs feel right at home.

</p>
<h4 id="batman-js-its-got-platforms">Platforms</h4>
<p>Batman runs in node and the browser. Batman supports node v0.8.x. We&#39;re targeting Chrome, Safari 4+, Firefox 3+, and IE 7+ for compatibility. Batman expects ES5 features like <code>Function::bind</code> and <code>Array::map</code>, so we recommend poly-filling these for older browsers with something like <a href="https://github.com/kriskowal/es5-shim">es5shim</a> or <a href="http://augmentjs.com/">augmentjs</a>. Batman also expects <code>JSON.parse</code>, which can be implemented in browsers without it using <a href="https://github.com/douglascrockford/JSON-js">json2.js</a>.

</p>
<h2 id="batman-js-installation">Installation</h2>
<p>Batman is available as a standalone download or as an <code>npm</code> package.

</p>
<h3 id="batman-js-installation-standalone-browser-version">Standalone Browser Version</h3>
<p>Versions of batman suitable for use in a web application are available at GitHub.

</p>
<h3 id="batman-js-installation-node-js">node.js</h3>
<p>If you haven&#39;t already, you&#39;ll need to install <a href="http://nodejs.org">node.js</a>. Then:

</p>
<pre><code class="bash">npm install -g batman</code></pre>
<p>Generate a new batman.js app somewhere, called my_app:

</p>
<pre><code class="bash">cd ~/code
batman new my_app</code></pre>
<p>Fire it up:

</p>
<pre><code class="bash">cd my_app
batman server # (or just "batman s")</code></pre>
<p>Now visit <a href="http://localhost:1047"><a href="http://localhost:1047">http://localhost:1047</a></a> and start playing around!

</p>
<h2 id="batman-js-architecture">Architecture</h2>
<p>Batman prescribes an MVC architecture for client side applications which fits together like this:

</p>
<ul>
<li>Models have validations, lifecycle events, a built-in identity map, and can be told how to persist themselves. (<code>Batman.LocalStorage</code>, <code>Batman.RestStorage</code>, and <code>Batman.RailsStorage</code> are included).</li>
<li>Views are JavaScript classes which render templates written in pure HTML. The templates use <code>data-*</code> attributes to create bindings to model data and trigger event handlers.</li>
<li>Controllers are persistent objects which mediate access to the model data, render the views, and handle events from the views.</li>
</ul>
<p>A batman.js application is served up in one page load, followed by asynchronous requests for various resources as the user interacts with the app. Navigation within the app can use <a href="https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history#Adding_and_modifying_history_entries">pushState</a> where supported, or fall back on to <a href="http://www.w3.org/QA/2011/05/hash_uris.html">hash-bang fragment identifers</a>.
</p>

<h2 id="batman-helpers">Batman Helpers</h2>
<p>Batman includes an number of useful, general purpose helper functions and references. They can all be found attached to the <code>Batman</code> object and can optionally be exported into the global namespace with a <code>$</code> prefix.

</p>
<h3 id="batman-helpers-container">container</h3>
<p><code>Batman.container</code> points to either the <code>window</code> object if running in the browser, or the <code>global</code> object if running in node. This is useful if you want to add something to the global scope in all environments.

</p>
<h3 id="batman-helpers-typeof">typeOf(object) : string</h3>
<p><code>typeOf</code> determines a more specific type of an <code>object</code> than the native <code>typeof</code> operator in JavaScript. This is useful for a number of situations like dealing with <code>Object</code> promoted strings and numbers, or arrays which look like <code>object</code>s to <code>typeof</code>. Use <code>typeOf</code> when you need more than <code>&quot;object&quot;</code> from <code>typeof</code>.

</p>
<p><em>Note</em>: <code>typeOf</code> is substantially slower than <code>typeof</code>. <code>typeOf</code> works in a somewhat hackish manner by getting the <code>Object::toString</code> representation of the object and slicing it to retrieve the name of the constructor.

</p>
<div class="console-session">
  <h4>typeOf returns &quot;String&quot; for both strings and Object strings</h4>
  <pre><code class="javascript"><div class="in">primitive = "test"</div><div class="out"></div><div class="in">objectified = new String("test")</div><div class="out"></div><div class="in">typeof primitive</div><div class="out">"string"</div><div class="in">typeof objectified</div><div class="out">"object"</div><div class="in">Batman.typeOf(primitive)</div><div class="out">"String"</div><div class="in">Batman.typeOf(objectified)</div><div class="out">"String"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>typeOf returns Array for arrays</h4>
  <pre><code class="javascript"><div class="in">array = []</div><div class="out"></div><div class="in">typeof array</div><div class="out">"object"</div><div class="in">Batman.typeOf(array)</div><div class="out">"Array"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-mixin">mixin(subject, objects...) : subject</h3>
<p><code>mixin</code>, occasionally known elsewhere as <code>extend</code> or <code>merge</code>, flattens a series of objects onto the subject. Key/value pairs on objects passed as later arguments (arguments with a higher index) take precedence over earlier arguments. Returns the <code>subject</code> passed in with the new values.

</p>
<p><code>mixin</code> also has special properties that make it different than the canonical <code>extend</code> functions:

</p>
<ol>
<li>If the <code>subject</code> has a <code>set</code> function, <code>subject.set(key, value)</code> will be used to apply keys instead of <code>subject[key] = value</code>. This means that if the subject is a <code>Batman.Object</code>, observers and thus bindings on the object will be notified when other (Batmanified or not) objects are mixed into it.</li>
<li>If a mixed-in <code>object</code> has an <code>initialize</code> function defined, that function will be called and passed the <code>subject</code>. This is useful for custom extension logic, similar to <code>self.included</code> in Ruby. For this reason, the keys <code>initialize</code> and <code>uninitialize</code> are skipped by <code>mixin</code>.</li>
<li><code>mixin</code> only iterates over keys for which the <code><a href="function hasOwnProperty() { [native code] }">hasOwnProperty</a></code> test passes.</li>
</ol>
<p><em>Note</em>: <code>mixin</code> is destructive to (only) the first argument. If you need a non-destructive version of <code>mixin</code>, just pass an empty object as the first object, and all keys from the successive arguments will be applied to the empty object.

</p>
<div class="console-session">
  <h4>mixin merges argument objects</h4>
  <pre><code class="javascript"><div class="in">subject = {}</div><div class="out"></div><div class="in">Batman.mixin(subject, {
    fit: true
  }, {
    fly: true
  }, {
    funky: true
  })</div><div class="out">{
    fit: true,
    fly: true,
    funky: true
  } // mixin returns the subject</div><div class="in">subject</div><div class="out">{
    fit: true,
    fly: true,
    funky: true
  } // the subject is modified destructively</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>mixin merges argument objects</h4>
  <pre><code class="javascript"><div class="in">unmodified = {
    fit: true
  }</div><div class="out"></div><div class="in">Batman.mixin({}, unmodified, {
    fly: true
  }, {
    funky: true
  })</div><div class="out">{
    fit: true,
    fly: true,
    funky: true
  } // mixin returns the subject</div><div class="in">unmodified</div><div class="out">{
    fit: true
  } // argument objects are untouched allowing non-destructive merge</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>mixed in objects passed as higher indexed arguments take precedence</h4>
  <pre><code class="javascript"><div class="in">subject = {}</div><div class="out"></div><div class="in">Batman.mixin(subject, {
    x: 1,
    y: 1
  }, {
    x: 2
  })</div><div class="out">{
    x: 2,
    y: 1
  }</div></code>
  </pre>
</div>
<h3 id="batman-helpers-unmixin">unmixin(subject, objects...) : subject</h3>
<p><code>unmixin</code> &quot;unmerges&quot; the passes objects from the <code>subject</code>. If a key exists on any of the <code>objects</code> it will be <code>delete</code>d from the <code>subject</code>. Returns the <code>subject</code>.

</p>
<p><code>unmixin</code>, similar to <code>mixin</code>, supports calling an <code>uninitialize</code> function for each of the <code>objects</code> being unmixed in. If an <code>uninitialize</code> function exists on each

</p>
<div class="console-session">
  <h4>unmixin removes keys found on the unmixined objects on the subject</h4>
  <pre><code class="javascript"><div class="in">subject = {
    fit: true,
    fly: true,
    funky: true
  }</div><div class="out"></div><div class="in">Batman.unmixin(subject, {
    fit: true
  }, {
    fly: true
  })</div><div class="out">{
    funky: true
  } // unmixin returns the subject</div><div class="in">subject</div><div class="out">{
    funky: true
  } // the subject is destructively modified.</div></code>
  </pre>
</div>
<h3 id="batman-helpers-ischildof">isChildOf(parent : HTMLElement, child : HTMLElement) : boolean</h3>
<p><code>isChildOf</code> is a simple DOM helper which returns a boolean describing if the passed <code>child</code> node can be found in the descendants of the passed <code>parent</code> node.

</p>
<h3 id="batman-helpers-setimmediate">setImmediate(callback : Function) : object</h3>
<p><code>setImmediate</code> (and its sister <code>clearImmediate</code>) are a more efficient version of <code>setTimeout(callback, 0)</code>. Due to timer resolution issues, setTimeout passed a timeout of 0 doesn&#39;t actually execute the function as soon as the JS execution stack has been emptied, but at minimum 4ms and maxmium 25ms after. For this reason Batman provides a cross browser implementation of <code>setImmediate</code> which does its best to call the callback immediately after the stack empties. Batman&#39;s <code>setImmediate</code> polyfill uses the native version if available, <code>window.postmessage</code> trickery if supported, and falls back on <code>setTimeout(-&gt;, 0)</code>.

</p>
<p><code>setImmediate</code> returns a handle which can be passed to <code>clearImmediate</code> to cancel the future calling of the callback.

</p>
<h3 id="batman-helpers-clearimmediate">clearImmediate(handle)</h3>
<p><code>clearImmediate</code> stops the calling of a callback in the future when passed its <code>handle</code> (which is returned from the <code>setImmediate</code> call used to enqueue it).

</p>
<h3 id="batman-helpers-foreach">forEach(iterable : object, iterator : Function[, context : Object])</h3>
<p>The <code>forEach</code> Batman helper is a universal iteration helper. When passed an <code>iterable</code> object, the helper will call the <code>iterator</code> (optionally in the <code>context</code>) for each item in the <code>iterable</code>. The <code>iterable</code> can be:

</p>
<ol>
<li>something which has its own <code>forEach</code>, in which case the <code>iterator</code> will just be passed to <code>iterable.forEach</code>.</li>
<li>an array like object, in which case a JavaScript <code>for(;;)</code> loop will be used to iterate over each entry</li>
<li>or an object, in which case a JavaScript <code>for-in</code> loop will be used to iterate over each entry.</li>
</ol>
<p>The <code>forEach</code> helper is useful for iterating over objects when the type of those objects isn&#39;t guaranteed.

</p>
<div class="console-session">
  <h4>forEach iterates over objects with forEach defined</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a')</div><div class="out"></div><div class="in">Batman.forEach(set, function(x) {
    return log(x);
  })</div><div class="out"></div><div class="in">logged.last</div><div class="out">"a"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>forEach iterates over array like objects</h4>
  <pre><code class="javascript"><div class="in">ArrayLike = function() {}</div><div class="out"></div><div class="in">ArrayLike.prototype = []</div><div class="out"></div><div class="in">imitation = new ArrayLike</div><div class="out"></div><div class="in">Array.prototype.push.call(imitation, "a")</div><div class="out"></div><div class="in">Array.prototype.push.call(imitation, "b")</div><div class="out"></div><div class="in">Batman.forEach(imitation, function(x) {
    return log(x);
  })</div><div class="out"></div><div class="in">logged.last</div><div class="out">"b"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>forEach iterates over objects</h4>
  <pre><code class="javascript"><div class="in">object = {
    x: true
  }</div><div class="out"></div><div class="in">Batman.forEach(object, function(key, val) {
    return log({
      key: key,
      val: val
    });
  })</div><div class="out"></div><div class="in">logged.last</div><div class="out">{
    key: 'x',
    val: true
  }</div></code>
  </pre>
</div>
<h3 id="batman-helpers-objecthaskey">objectHasKey(object, key) : boolean</h3>
<p><code>objectHasKey</code> returns a boolean describing the presence of the <code>key</code> in the passed <code>object</code>. <code>objectHasKey</code> delegates to the <code>object</code>&#39;s <code>hasKey</code> function if present, and otherwise just does a check using the JavaScript <code>in</code> operator.

</p>
<div class="console-session">
  <h4>objectHasKey verifies if a key is present in an object</h4>
  <pre><code class="javascript"><div class="in">subject = {
    fit: true
  }</div><div class="out"></div><div class="in">Batman.objectHasKey(subject, 'fit')</div><div class="out">true</div><div class="in">Batman.objectHasKey(subject, 'flirty')</div><div class="out">false</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>objectHasKey verifies if a key is present in an object with `hasKey` defined</h4>
  <pre><code class="javascript"><div class="in">subject = new Batman.SimpleHash({
    fit: true
  })</div><div class="out"></div><div class="in">Batman.objectHasKey(subject, 'fit')</div><div class="out">true</div><div class="in">Batman.objectHasKey(subject, 'flirty')</div><div class="out">false</div></code>
  </pre>
</div>
<h3 id="batman-helpers-contains">contains(object, item) : boolean</h3>
<p><code>contains</code> returns a boolean describing if the given <code>object</code> has member <code>item</code>. Membership in this context is defined as:

</p>
<ul>
<li>the result of <code>object.has(item)</code> if the <code>object</code> has a <code>has</code> function defined</li>
<li>the result of <code>item in object</code> if the <code>object</code> is arraylike</li>
<li>the result of the Batman.objectHasKey otherwise</li>
</ul>
<p><em>Note</em>: When passed an object without a <code>has</code> function, <code>contains</code> will return <code>true</code> if the <code>object</code> has <code>item</code> as a <em><code>key</code></em>, not as a value at any key.

</p>
<p><code>contains</code> is useful for checking item membership when the type of the object can&#39;t be relied on.

</p>
<h3 id="batman-helpers-get">get(object, key) : value</h3>
<p><code>get</code> is a general purpose function for retrieving the value from a <code>key</code> on an <code>object</code> of an indeterminate type. This is useful if code needs to work with both <code>Batman.Object</code>s and Plain Old JavaScript Objects. <code>get</code> has the following semantics:

</p>
<ul>
<li>if the <code>object</code> has a <code>get</code> function defined, return the result of <code>object.get(key)</code></li>
<li>if the object does not have a <code>get</code> function defined, use an ephemeral <code>Batman.Property</code> to retrieve the key. This is equivalent to <code>object[key]</code> for single segment <code>key</code>s, but if the <code>key</code> is multi-segment (example: &#39;product.customer.name&#39;), <code>get</code> will do nested gets until the either <code>undefined</code> or the end of the keypath is reached.</li>
</ul>
<div class="console-session">
  <h4>get returns the value at a key on a POJO</h4>
  <pre><code class="javascript"><div class="in">subject = {
    fit: true
  }</div><div class="out"></div><div class="in">Batman.get(subject, 'fit')</div><div class="out">true</div><div class="in">Batman.get(subject, 'flirty')</div><div class="out">void 0</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>get returns the value at a key on a Batman.Object</h4>
  <pre><code class="javascript"><div class="in">subject = Batman({
    fit: true
  })</div><div class="out"></div><div class="in">Batman.get(subject, 'fit')</div><div class="out">true</div><div class="in">Batman.get(subject, 'flirty')</div><div class="out">void 0</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>get returns the value at a deep key on a POJO</h4>
  <pre><code class="javascript"><div class="in">subject = {
    customer: {
      name: "Joe"
    }
  }</div><div class="out"></div><div class="in">Batman.get(subject, 'customer.name')</div><div class="out">"Joe"</div><div class="in">Batman.get(subject, 'customer.age')</div><div class="out">void 0</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>get returns the value at a deep key on a Batman.Object</h4>
  <pre><code class="javascript"><div class="in">subject = Batman({
    customer: {
      name: "Joe"
    }
  })</div><div class="out"></div><div class="in">Batman.get(subject, 'customer.name')</div><div class="out">"Joe"</div><div class="in">Batman.get(subject, 'customer.age')</div><div class="out">void 0</div></code>
  </pre>
</div>
<h3 id="batman-helpers-escapehtml">escapeHTML(string) : string</h3>
<p><code>escapeHTML</code> takes a string of unknown origin and makes it safe for display on a web page by encoding control characters in HTML into their HTML entities.

</p>
<p><em>Warning</em>: Do not rely on <code>escapeHTML</code> to purge unsafe data from user submitted content. While <code>escapeHTML</code> is applied to every binding&#39;s contents by default, it should not be your only line of defence against script injection attacks.

</p>
<div class="console-session">
  <h4>escapeHTML encodes special characters into HTML entities</h4>
  <pre><code class="javascript"><div class="in">Batman.escapeHTML("& < > \" '")</div><div class="out">"&amp; &lt; &gt; &#34; &#39;"</div></code>
  </pre>
</div>
<h2 id="batman-helpers">Batman.helpers</h2>
<p><code>Batman.helpers</code> is a namespace for Batman&#39;s helpful string manipulation helpers.

</p>
<p><em>Note</em>: Batman&#39;s pluralization functions mirror those of Rails&#39; exactly.

</p>
<h3 id="batman-helpers-ordinalize">ordinalize(value : [number|string]) : string</h3>
<p><code>ordinalize</code> converts a given integer into an ordinal string for describing position in a list, like 1st, 2nd, or 20th.

</p>
<div class="console-session">
  <h4>ordinalize converts numbers to their ordinal form</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.ordinalize(1)</div><div class="out">"1st"</div><div class="in">Batman.helpers.ordinalize("2")</div><div class="out">"2nd"</div><div class="in">Batman.helpers.ordinalize(1002)</div><div class="out">"1002nd"</div><div class="in">Batman.helpers.ordinalize("1003")</div><div class="out">"1003rd"</div><div class="in">Batman.helpers.ordinalize(-11)</div><div class="out">"-11th"</div><div class="in">Batman.helpers.ordinalize(-1021)</div><div class="out">"-1021st"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-singularize">singularize(pluralString : string) : string</h3>
<p><code>singularize</code> converts the plural form of a word to a singular form.

</p>
<div class="console-session">
  <h4>singularize converts plural words to singular words</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.singularize("posts")</div><div class="out">"post"</div><div class="in">Batman.helpers.singularize("octopi")</div><div class="out">"octopus"</div><div class="in">Batman.helpers.singularize("sheep")</div><div class="out">"sheep"</div><div class="in">Batman.helpers.singularize("word")</div><div class="out">"word"</div><div class="in">Batman.helpers.singularize("CamelOctopi")</div><div class="out">"CamelOctopus"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-pluralize">pluralize(singularString : string) : string</h3>
<p><code>pluralize</code> converts the singular form of a word to the plural form.

</p>
<div class="console-session">
  <h4>pluralize converts plural words to singular words</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.pluralize("post")</div><div class="out">"posts"</div><div class="in">Batman.helpers.pluralize("octopus")</div><div class="out">"octopi"</div><div class="in">Batman.helpers.pluralize("sheep")</div><div class="out">"sheep"</div><div class="in">Batman.helpers.pluralize("words")</div><div class="out">"words"</div><div class="in">Batman.helpers.pluralize("CamelOctopus")</div><div class="out">"CamelOctopi"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-camelize">camelize(string, [lowercaseFirstLetter = false]) : string</h3>
<p><code>camelize</code> converts the passed <code>string</code> to UpperCamelCase. If the second argument is passed as <code>true</code>, then lowerCamelCase is returned.

</p>
<div class="console-session">
  <h4>camelize returns the CamelCase version of an under_scored word</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.camelize("batman_object")</div><div class="out">"BatmanObject"</div><div class="in">Batman.helpers.camelize("batman_object", true)</div><div class="out">"batmanObject"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-underscore">underscore(string) : string</h3>
<p><code>underscore</code> returns the underscored version of a CamelCase word.

</p>
<div class="console-session">
  <h4>underscore converts CamelCase to under_scores</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.underscore("BatmanObject")</div><div class="out">"batman_object"</div></code>
  </pre>
</div>
<h3 id="batman-helpers-capitalize">capitalize(string) : string</h3>
<p><code>capitalize</code> does a word-wise capitalization of a phrase or word.

</p>
<div class="console-session">
  <h4>capitalize makes the first letter of each word in the string uppercase</h4>
  <pre><code class="javascript"><div class="in">Batman.helpers.capitalize("batmanObject")</div><div class="out">"BatmanObject"</div><div class="in">Batman.helpers.capitalize("batman object")</div><div class="out">"Batman Object"</div><div class="in">Batman.helpers.capitalize("AlreadyCapitalized")</div><div class="out">"AlreadyCapitalized"</div></code>
  </pre>
</div>

<h2 id="batman-eventemitter">Batman.EventEmitter</h2>
<p><code>EventEmitter</code> is a mixin which can be applied to any object to give it the ability to fire events and accept listeners for those events.

</p>
<h3 id="batman-eventemitter-on">on(key, handler)</h3>
<p>Attaches a function <code>handler</code> to the event with name <code>key</code>. This function will be executed every time the event fires.

</p>
<div class="console-session">
  <h4>event handlers execute when attached with on</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("detonated");
  })</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-fire">fire(key, arguments...)</h3>
<p>Calls all previously attached handlers on the event with name <code>key</code>. All handlers will receive the passed <code>arguments</code>.

</p>
<p><em>Note</em>: Calling <code>fire</code> doesn&#39;t guarantee the event will fire since firing can be prevented with <code>prevent</code> or <code>preventAll</code>.

</p>
<div class="console-session">
  <h4>event handlers are fired</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.on('detonate', function(noise) {
    return log("detonated with noise " + noise);
  })</div><div class="out"></div><div class="in">dynamite.fire('detonate', "BOOM!")</div><div class="out"></div><div class="in">logged.last</div><div class="out">"detonated with noise BOOM!"</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-hasevent">hasEvent(key) : boolean</h3>
<p>Asks if the <code>EventEmitter</code> has an event with the given <code>key</code>.

</p>
<div class="console-session">
  <h4>events can be tested for presence</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("detonated");
  })</div><div class="out"></div><div class="in">dynamite.hasEvent('detonate')</div><div class="out">true</div><div class="in">dynamite.hasEvent('click')</div><div class="out">false</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-oneshot">oneShot : boolean</h3>
<p>Events can be set to fire only once, and then fire subsequently attached handlers immediately if they are attached after the initial firing. This is useful for events similar to <code>window.onload</code> where they really only happen once in the lifespan of the application, but you don&#39;t want to check if they have happened already when attaching event handlers.

</p>
<p>Access the <code>Event</code> object to set the <code>oneShot</code> property on them using <code>EventEmitter::event</code>.

</p>
<div class="console-session">
  <h4>one shot events fire handlers attached after they have fired for the first time</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.event('detonate').oneShot = true</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("detonated immediately!!");
  })</div><div class="out"></div><div class="in">logged.last</div><div class="out">"detonated immediately!!" // The handler was called as soon as it was attached.</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-prevent">prevent(key) : EventEmitter</h3>
<p>Prevents the event with name <code>key</code> from firing, even if <code>.fire</code> is called. This is useful if you need to guarantee a precondition is in fulfilled before allowing event handlers to execute. Returns the event emitting object.

</p>
<p>Undo event prevention with <code>allow</code> or <code>allowAndFire</code>.

</p>
<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.


</p>
<div class="console-session">
  <h4>events can be prevented</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("This shouldn't fire");
  })</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.last</div><div class="out">void 0 // The event handler wasn't fired.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>prevent returns the event emitter</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite</div><div class="out">dynamite.prevent('detonate')</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-allow">allow(key) : EventEmitter</h3>
<p>Allows the event with name <code>key</code> to fire once more, after <code>prevent</code> had been called previously. <code>allow</code> will not fire the event when called, regardless of weather or not the event can now be fired or if an attempt to fire it was made while the event was prevented. Returns the event emitting object.

</p>
<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.

</p>
<div class="console-session">
  <h4>events can be allowed after prevention</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("This will only fire once");
  })</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">0 // The event handler wasn't fired.</div><div class="in">dynamite.allow('detonate')</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">1 // The event handler was fired.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>events must be allowed the same number of times they have been prevented</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("This will only fire once");
  })</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">0 // The event handler wasn't fired, the prevent count is at 2.</div><div class="in">dynamite.allow('detonate')</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">0 // The event handler still wasn't fired, but the prevent count is now at 1.</div><div class="in">dynamite.allow('detonate')</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">1 // The event handler was fired.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>allow returns the event emitter</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite</div><div class="out">dynamite.allow('detonate')</div></code>
  </pre>
</div>
<h3 id="batman-eventemitter-allowandfire">allowAndFire(key)</h3>
<p>Allows the event with name <code>key</code> to fire once more, and tries to fire it. <code>allowAndFire</code> may fail to fire the event if <code>prevent</code> has been called more times than <code>allow</code> or <code>allowAndFire</code> have previous.

</p>
<div class="console-session">
  <h4>events can be allowed and fired after prevention</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("This will only fire once");
  })</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.fire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">0 // The event handler wasn't fired.</div><div class="in">dynamite.allowAndFire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">1 // The event handler was fired.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>events must be be allowed and fired the same number of times they have been prevented</h4>
  <pre><code class="javascript"><div class="in">dynamite = $mixin({}, Batman.EventEmitter)</div><div class="out"></div><div class="in">dynamite.on('detonate', function() {
    return log("This will only fire once");
  })</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.prevent('detonate')</div><div class="out"></div><div class="in">dynamite.allowAndFire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">0 // The event handler wasn't fired.</div><div class="in">dynamite.allowAndFire('detonate')</div><div class="out"></div><div class="in">logged.length</div><div class="out">1 // The event handler was fired.</div></code>
  </pre>
</div>

<h2 id="batman-observable">Batman.Observable</h2>
<p><code>Batman.Observable</code> is a mixin which gives objects the ability to notify subscribers to changes on its properties. <code>Observable</code> also adds functionality for observing <em>keypaths</em>: arbitrarily deeply nested properties on objects.

</p>
<h3 id="batman-observable-get">get(keypath) : value</h3>
<p>Retrieves the value at a <code>key</code> on an object. Accepts keypaths.

</p>
<p><em>Note</em>: <code>get</code> must be used for property access on any object in <code>Batman</code>&#39;s world. This is so that Batman can implement neat things like automatic dependency calculation for computed properties, property caching where it is safe, and smart storage mechanisms. With Batman, you must use <code>get</code> instead of normal <code>.</code> property access.

</p>
<div class="console-session">
  <h4>get retrieves properties on Batman objects</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.get('length')</div><div class="out">340</div><div class="in">song.get('bpm')</div><div class="out">120</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>get retrieves properties on nested Batman objects using keypaths</h4>
  <pre><code class="javascript"><div class="in">post = Batman({
    text: "Hello World!",
    author: Batman({
      name: "Harry"
    })
  })</div><div class="out"></div><div class="in">post.get('author.name')</div><div class="out">"Harry"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>get retrieves properties on Batman objects when . property access doesn&#39;t</h4>
  <pre><code class="javascript"><div class="in">song = new Batman.Model({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">typeof song.length</div><div class="out">"undefined"</div><div class="in">song.get('length')</div><div class="out">340</div></code>
  </pre>
</div>
<h3 id="batman-observable-set">set(keypath, newValue) : newValue</h3>
<p>Stores the <code>value</code> at a <code>key</code> on an object. Accepts keypaths. Returns the new value of the property.

</p>
<p><em>Note</em>: Once more, <code>set</code> must be used for property mutation on all objects in the <code>Batman</code> world. This is again so that Batman can implement useful functionality like cache busting, eager recalculation of computed properties, and smarter storage.

</p>
<p><em>Note</em>: Custom setters can mutate the value during setting, so the value which was passed to <code>set</code> and <code>set</code>&#39;s return value are not guaranteed to be identical.

</p>
<div class="console-session">
  <h4>set stores properties on batman objects.</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.get('length')</div><div class="out">340</div><div class="in">song.set('length', 1000)</div><div class="out">1000</div><div class="in">song.get('length')</div><div class="out">1000</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>set stores properties on nested Batman objects using keypaths</h4>
  <pre><code class="javascript"><div class="in">author = Batman({
    name: "Harry"
  })</div><div class="out"></div><div class="in">post = Batman({
    text: "Hello World!",
    author: author
  })</div><div class="out"></div><div class="in">post.set('author.name', "Nick")</div><div class="out">"Nick"</div><div class="in">author.get('name')</div><div class="out">"Nick" // The value was set on the nested object.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>set is incompatible with &#39;.&#39; property mutation</h4>
  <pre><code class="javascript"><div class="in">song = new Batman.Model({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.get('length')</div><div class="out">340</div><div class="in">song.length = 1000</div><div class="out">1000</div><div class="in">song.get('length')</div><div class="out">340 // The song length reported by Batman is unchanged because set wasn't used to change the value.</div></code>
  </pre>
</div>
<h3 id="batman-observable-unset">unset(keypath) : value</h3>
<p>Removes the value at the given <code>keypath</code>, leaving it <code>undefined</code>. Accepts keypaths. Returns the value the property had before unsetting.

</p>
<p><code>unset</code> is roughly equivalent to <code>set(keypath, undefined)</code>, however, custom properties can define a nonstandard <code>unset</code> function, so it is best to use <code>unset</code> instead of <code>set(keypath, undefined)</code> wherever possible.

</p>
<div class="console-session">
  <h4>unset removes the property on Batman objects</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.get('length')</div><div class="out">340</div><div class="in">song.unset('length')</div><div class="out">340</div><div class="in">song.get('length')</div><div class="out">void 0 // The value is unset.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>unset removes the property at a keypath</h4>
  <pre><code class="javascript"><div class="in">author = Batman({
    name: "Harry"
  })</div><div class="out"></div><div class="in">post = Batman({
    text: "Hello World!",
    author: author
  })</div><div class="out"></div><div class="in">post.unset('author.name')</div><div class="out">"Harry"</div><div class="in">author.get('name')</div><div class="out">void 0 // The value was unset on the nested object.</div></code>
  </pre>
</div>
<h3 id="batman-observable-observe">observe(key, observerCallback) : this</h3>
<p>Adds a handler to call when the value of the property at the <code>key</code> changes upon <code>set</code>ting. Accepts keypaths.

</p>
<p><code>observe</code> is the very core of Batman&#39;s usefulness. As long as <code>set</code> is used everywhere to do property mutation, any object can be observed for changes to its properties. This is critical to the concept of bindings, which Batman uses for its views.

</p>
<p>The <code>observerCallback</code> gets called whenever the <code>key</code> changes with the arguments <code>newValue, oldValue</code>.

</p>
<p>Returns the object <code>observe</code> was called upon.

</p>
<div class="console-session">
  <h4>observe attaches handlers which get called upon change</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.observe('length', function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.last</div><div class="out">[200, 340]</div><div class="in">song.set('length', 300)</div><div class="out">300</div><div class="in">logged.last</div><div class="out">[300, 200]</div></code>
  </pre>
</div>
<p><em>Note</em>: <code>observe</code> works excellently on keypaths. If you attach a handler to a &quot;deep&quot; keypath, it will fire any time the value of that keypath changes, which is another way of saying the handler will fire when any segment of the keypath changes, passing in the new value at the end of the keypath.

</p>
<div class="console-session">
  <h4>observe attaches handlers which get called upon change</h4>
  <pre><code class="javascript"><div class="in">author = Batman({
    name: "Harry"
  })</div><div class="out"></div><div class="in">post = Batman({
    text: "Hello World!",
    author: author
  })</div><div class="out"></div><div class="in">post.observe('author.name', function(newName, oldName) {
    return log([newName, oldName]);
  })</div><div class="out"></div><div class="in">post.set('author', newAuthor = Batman({
    name: "James"
  }))</div><div class="out"></div><div class="in">logged.last</div><div class="out">["James", "Harry"] // The observer fired when the 'author' segment of the keypath changed.</div></code>
  </pre>
</div>
<h3 id="batman-observable-observeandfire">observeAndFire(key, observerCallback) : this</h3>
<p>Adds the <code>observerCallback</code> as an observer to <code>key</code>, and fires it immediately. Accepts the exact same arguments and follows the same semantics as <code>Observable::observe</code>, but the observer is fired with the current value of the keypath it observers synchronously during the call to <code>observeAndFire</code>.

</p>
<p>During the initial synchronous firing of the <code>callback</code>, the <code>newValue</code> and <code>oldValue</code> arguments will be the same value: the current value of the property. This is because the old value of the property is not cached and therefore unavailable. If your observer needs the old value of the property, you must attach it before the <code>set</code> on the property happens.

</p>
<div class="console-session">
  <h4>observeAndFire calls the observer upon attaching it with the currentValue of the property</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.observeAndFire('length', function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">logged.last</div><div class="out">[340, 340]</div><div class="in">song.set('length', 300)</div><div class="out">300</div><div class="in">logged.last</div><div class="out">[300, 340]</div></code>
  </pre>
</div>
<h3 id="batman-observable-forget">forget([key [, observerCallback]]) : this</h3>
<p>If <code>observerCallback</code> and <code>key</code> are given, that observer is removed from the observers on <code>key</code>. If only a <code>key</code> is given, all observers on that key are removed. If no <code>key</code> is given, all observers on all keys are removed. Accepts keypaths.

</p>
<p>Returns the object <code>forget</code> was called upon.

</p>
<div class="console-session">
  <h4>forget removes an observer from a key if the key and the observer are given</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">observer = function(newValue, oldValue) {
    return log([newValue, oldValue]);
  }</div><div class="out"></div><div class="in">song.observe('length', observer)</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.last</div><div class="out">[200, 340]</div><div class="in">song.forget('length', observer)</div><div class="out"></div><div class="in">song.set('length', 300)</div><div class="out">300</div><div class="in">logged.last</div><div class="out">[200, 340] // The logged values haven't changed because the observer hasn't fired again.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>forget removes all observers from a key if only the key is given</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">observerA = (function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">observerB = (function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">song.observe('length', observerA)</div><div class="out"></div><div class="in">song.observe('length', observerB)</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.length</div><div class="out">2 // Both length observers fired.</div><div class="in">song.forget('length')</div><div class="out"></div><div class="in">song.set('length', 300)</div><div class="out">300</div><div class="in">logged.length</div><div class="out">2 // Nothing more has been logged because neither observer fired.</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>forget removes all observers from all key if no key is given</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">observerA = (function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">observerB = (function(newValue, oldValue) {
    return log([newValue, oldValue]);
  })</div><div class="out"></div><div class="in">song.observe('length', observerA)</div><div class="out"></div><div class="in">song.observe('bpm', observerB)</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.length</div><div class="out">1 // The length observer fired.</div><div class="in">song.forget()</div><div class="out"></div><div class="in">song.set('length', 300)</div><div class="out">300</div><div class="in">song.set('bpm', 130)</div><div class="out">130</div><div class="in">logged.length</div><div class="out">1 // Nothing more has been logged because neither observer fired.</div></code>
  </pre>
</div>
<h3 id="batman-observable-getorset">getOrSet(keypath, valueFunction) : value</h3>
<p>Assigns the <code>keypath</code> to the result of calling the <code>valueFunction</code> if the current value at the <code>keypath</code> is falsey. Returns the value of the property after the operation, be it changed or not. Equivalent to CoffeeScript&#39;s <code>||=</code> operator.

</p>
<div class="console-session">
  <h4>getOrSet doesn&#39;t set the property if it exists</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.getOrSet('length', function() {
    return 500;
  })</div><div class="out">340</div><div class="in">song.get('length')</div><div class="out">340</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>getOrSet sets the property if it is falsey</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.getOrSet('artist', function() {
    return "Elvis";
  })</div><div class="out">"Elvis"</div><div class="in">song.get('artist')</div><div class="out">"Elvis"</div></code>
  </pre>
</div>

<h2 id="batman-object">Batman.Object</h2>
<p><code>Batman.Object</code> is the superclass for virtually all objects in a Batman application. <code>Batman.Object</code> mixes in <code>Batman.Observable</code> and <code>Batman.EventEmitter</code> for things like <code>get</code>, <code>set</code>, <code>observe</code>, and <code>fire</code>, and then defines some more useful things for tying everything together.

</p>
<h3 id="batman-object-accessor">@accessor([keys...], objectOrFunction)</h3>
<p>Accessors are used to create properties on a class, prototype, or instance which can be fetched, set, and unset. These properties can be static, computed as functions of the other properties on the object the accessor belongs to, or properties of any Batman object in the system. <code>accessor</code> is a Batman and old browser friendly version of ES5 <code>Object.defineProperty</code> missing some of the goodness.

</p>
<p>The value of custom accessors can be observed just like any property. Accessors also track which other properties they rely on for computation, and recalculate eagerly when those other properties change. This way, when a source value is changed, any dependent accessors will automatically update any bindings to them with a new value. Accessors accomplish this feat by tracking <code>get</code> calls, so do be sure to use <code>get</code> to retrieve properties on Batman Objects inside accessors so those properties can be tracked as dependencies. The property dependencies of an accessor are called &quot;sources&quot; in the Batman world.

</p>
<p>Importantly, accessors are also inherited, so accessors defined anywhere in an object&#39;s prototype chain will be used. Following this, <code>@accessor</code> is meant to be used during the class definition of a class extending <code>Batman.Object</code>.

</p>
<h4 id="batman-object-accessor-arguments">Arguments</h4>
<p><code>@accessor</code> can be called with zero, one, or many keys for the accessor to define. This has the following effects:

</p>
<ul>
<li>zero: create a <code>defaultAccessor</code>, which will be called when no other properties or accessors on an object match a keypath. This is similar to <code>method_missing</code> in Ruby or <code>#doesNotUnderstand</code> in Smalltalk.</li>
<li>one: create a <code>keyAccessor</code> at the given key, which will only be called when that key is gotten, set, or unset.</li>
<li>many: create <code>keyAccessors</code> for each given key, which will then be called whenever each one of the listed keys is gotten, set, or unset.</li>
</ul>
<p><code>@accessor</code> accepts as the last argument either an object with any combination of the <code>get</code>, <code>set</code>, and <code>unset</code> keys defined. Functions which implement the behaviour for those particular actions on the property should reside at these keys. <code>@accessor</code> also accepts a function as the last argument, which is a shorthand for specifying the <code>get</code> implementation for the accessor.

</p>
<h4 id="batman-object-accessor-uses">Uses</h4>
<p>Accessors are a really useful addition to the world of JavaScript. You can now define transforms on simple properties which will automatically update when the properties they transform change, for example you might want to truncate a potentially long piece of text to display a summary elsewhere, or you might want to capitalize or <code>encodeURIComponent</code> a value before putting it in the view or the current URL.

</p>
<div class="console-session">
  <h4>@accessor can be called on a class to define how a property is calculated</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.accessor('summary', function() {
      return this.get('body').slice(0, 10) + "...";
    });

    return Post;

  })(Batman.Object)</div><div class="out"></div><div class="in">post = new Post({
    body: "Why Batman is Useful: A lengthy post on an important subject"
  })</div><div class="out"></div><div class="in">post.get('summary')</div><div class="out">"Why Batman..."</div></code>
  </pre>
</div>
<p>You can also use accessors to combine properties; the colloquial <code>fullName</code> example comes to mind, but all sorts of other complex logic can be abstracted away using the accessor pattern.

</p>
<div class="console-session">
  <h4>@accessor can define a transform on several properties</h4>
  <pre><code class="javascript"><div class="in">User = (function(_super) {

    __extends(User, _super);

    function User() {
      return User.__super__.constructor.apply(this, arguments);
    }

    User.accessor('fullName', function() {
      return this.get('firstName') + " " + this.get('lastName');
    });

    return User;

  })(Batman.Object)</div><div class="out"></div><div class="in">tim = new User({
    firstName: "Tim",
    lastName: "Thomas"
  })</div><div class="out"></div><div class="in">tim.get('fullName')</div><div class="out">"Tim Thomas"</div><div class="in">tim.set('firstName', "Timmy")</div><div class="out"></div><div class="in">tim.get('fullName')</div><div class="out">"Timmy Thomas"</div></code>
  </pre>
</div>
<p>Accessors can define custom <code>get</code>, <code>set</code>, and <code>unset</code> functions to support each operation on the property:

</p>
<div class="console-session">
  <h4>@accessor can define the get, set, and unset methods for the property</h4>
  <pre><code class="javascript"><div class="in">AbsoluteNumber = (function(_super) {

    __extends(AbsoluteNumber, _super);

    function AbsoluteNumber() {
      return AbsoluteNumber.__super__.constructor.apply(this, arguments);
    }

    AbsoluteNumber.accessor('value', {
      get: function() {
        return this._value;
      },
      set: function(_, value) {
        return this._value = Math.abs(value);
      },
      unset: function() {
        return delete this._value;
      }
    });

    return AbsoluteNumber;

  })(Batman.Object)</div><div class="out"></div><div class="in">number = new AbsoluteNumber({
    value: -10
  })</div><div class="out"></div><div class="in">number.get('value')</div><div class="out">10</div></code>
  </pre>
</div>
<p>Importantly, it is also safe to use branching, loops, or whatever logic you want in accessor bodies:

</p>
<div class="console-session">
  <h4>@accessor can use arbitrary logic to define the value</h4>
  <pre><code class="javascript"><div class="in">Player = (function(_super) {

    __extends(Player, _super);

    function Player() {
      return Player.__super__.constructor.apply(this, arguments);
    }

    Player.accessor('score', function() {
      if (this.get('played')) {
        return (this.get('goals') * 2) + (this.get('assists') * 1);
      } else {
        return 0;
      }
    });

    return Player;

  })(Batman.Object)</div><div class="out"></div><div class="in">rick = new Player({
    played: false,
    goals: 0,
    assists: 0
  })</div><div class="out"></div><div class="in">rick.get('score')</div><div class="out">0</div><div class="in">rick.set('played', true)</div><div class="out"></div><div class="in">rick.get('score')</div><div class="out">0</div><div class="in">rick.set('goals', 3)</div><div class="out"></div><div class="in">rick.get('score')</div><div class="out">6</div><div class="in">rick.set('assists', 1)</div><div class="out"></div><div class="in">rick.get('score')</div><div class="out">7</div></code>
  </pre>
</div>
<h4 id="batman-object-accessor-caveats">Caveats</h4>
<p>Accessors are extremely useful but you must keep these items in mind while programming using them:

</p>
<ol>
<li>Accessors should be pure functions so they are predictable and so they can be cached.</li>
</ol>
<p>Batman automatically memoizes the return value of accessors, and will not re-execute the body until one of the accessor&#39;s sources changes. If you need the accessor to recalculate every time the property is gotten, pass <code>false</code> for the <code>cache</code> option in the accessor descriptor object (the last argument to the <code>@accessor</code> function).

</p>
<div class="console-session">
  <h4>@accessor usually caches results</h4>
  <pre><code class="javascript"><div class="in">counter = 0</div><div class="out"></div><div class="in">Example = (function(_super) {

    __extends(Example, _super);

    function Example() {
      return Example.__super__.constructor.apply(this, arguments);
    }

    Example.accessor('cachedCounter', function() {
      return ++counter;
    });

    Example.accessor('notCachedCounter', {
      get: function() {
        return ++counter;
      },
      cache: false
    });

    return Example;

  })(Batman.Object)</div><div class="out"></div><div class="in">example = new Example()</div><div class="out"></div><div class="in">example.get('cachedCounter')</div><div class="out">1</div><div class="in">example.get('cachedCounter')</div><div class="out">1</div><div class="in">example.get('cachedCounter')</div><div class="out">1 // The second and third calls do not execute the function</div><div class="in">example.get('notCachedCounter')</div><div class="out">2</div><div class="in">example.get('notCachedCounter')</div><div class="out">3 // Passing cache: false does re-execute the function</div><div class="in">example.get('cachedCounter')</div><div class="out">1</div></code>
  </pre>
</div>
<ol>
<li>Accessors <em>must</em> use <code>get</code> to access properties they use for computation</li>
</ol>
<p>Batman tracks an accessor&#39;s sources by adding a global hook to all <code>get</code>s done, so if you don&#39;t use <code>get</code> to access properties on objects, Batman can&#39;t know that that property is a source of the property your accessor defines, so it can&#39;t recompute that property when the source property changes. All properties on <code>Batman.Object</code> should be accessed using <code>get</code> and <code>set</code> regardless if the code occurs in an accessor body or not, but it is critical to do so in accessors so the sources of the accessor can be tracked.

</p>
<ol>
<li>Accessors can create memory leaks or performance bottlenecks</li>
</ol>
<p>If you return a brand new object by say merging a number of <code>Batman.Set</code>s or doing any sort of major and complete re-computation you run the risk of creating performance problems. This is because accessors can be called frequently and unpredictably, as they are recomputed every time one of their sources changes as well as upon every <code>set</code>. Instead of recomputing expensive things every time the accessor is called, try to use objects which do smart re-computation using observers. Practically this translates to using things like <code>new SetUnion(@get(&#39;setA&#39;), @get(&#39;setB&#39;))</code> instead of <code>@get(&#39;setA&#39;).merge(@get(&#39;setB&#39;))</code> in an accessor body, since <code>SetUnion</code> will observe its constituents and update itsself when they change, instead of the <code>merge</code> resulting in the accessor recomputing every time <code>setA</code> or <code>setB</code> changed.

</p>
<h3 id="batman-object-classaccessor">@classAccessor([keys...], objectOrFunction)</h3>
<p><code>classAccessor</code> defines an accessor on the class, in that gets and sets done on the class will use the accessor definition as an implementation. <code>@accessor</code> called on a class will define an accessor for all instances of that class, where as <code>@classAccessor</code> defines accessors on the class object itself. See <code>@accessor</code> for the details surrounding accessors.

</p>
<div class="console-session">
  <h4>@classAccessor defines an accessor on the class</h4>
  <pre><code class="javascript"><div class="in">SingletonDooDad = (function(_super) {

    __extends(SingletonDooDad, _super);

    function SingletonDooDad() {
      return SingletonDooDad.__super__.constructor.apply(this, arguments);
    }

    SingletonDooDad.classAccessor('instance', function() {
      return new this();
    });

    return SingletonDooDad;

  })(Batman.Object)</div><div class="out"></div><div class="in">instance = SingletonDooDad.get('instance')</div><div class="out"></div><div class="in">SingletonDooDad.get('instance') === instance</div><div class="out">true // A second get returns the same instance</div></code>
  </pre>
</div>
<h3 id="batman-object-mixin">@mixin(objects...) : prototype</h3>
<p><code>@mixin</code> is a handy function for mixing in <code>objects</code> to a class&#39; prototype. <code>@mixin</code> is implemented on top of the Batman level <code>mixin</code> helper, which means that keys from incoming <code>objects</code> will be applied using <code>set</code>, and any <code>initialize</code> functions on the <code>objects</code> will be called with the prototype being mixed into. Returns the prototype being mixed into.

</p>
<p><em>Note</em>: <code>@mixin</code>, similar to <code>@accessor</code>, applies to all instances of a class. If you need to mix in to the class itself, look at <code>classMixin</code>.
<em>note</em>: <code>@mixin</code>, once more similar to <code>@accessor</code>, is intended for use during the class definition of a <code>Batman.Object</code> subclass.

</p>
<div class="console-session">
  <h4>@mixin extends the prototype of a Batman.Object subclass</h4>
  <pre><code class="javascript"><div class="in">FishBehaviour = {
    canBreathUnderwater: true
  }</div><div class="out"></div><div class="in">MammalBehaviour = {
    canBreathAboveWater: true
  }</div><div class="out"></div><div class="in">Platypus = (function(_super) {

    __extends(Platypus, _super);

    function Platypus() {
      return Platypus.__super__.constructor.apply(this, arguments);
    }

    Platypus.mixin(FishBehaviour, MammalBehaviour);

    return Platypus;

  })(Batman.Object)</div><div class="out"></div><div class="in">platypus = new Platypus</div><div class="out"></div><div class="in">platypus.get('canBreathAboveWater')</div><div class="out">true</div><div class="in">platypus.get('canBreathUnderwater')</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-object-classmixin">@classMixin(objects...) : this</h3>
<p><code>@classMixin</code> allows mixing in objects to a class during that class&#39; definition. See <code>@mixin</code> for information about the arguments passed to mixin, but note that <code>@classMixin</code> applies to the class object itself, and <code>@mixin</code> applies to all instances of the class. Returns the class being mixed into.

</p>
<div class="console-session">
  <h4>@classMixin extends the Batman.Object subclass</h4>
  <pre><code class="javascript"><div class="in">Singleton = {
    initialze: function(subject) {
      return subject.accessor('instance', function() {
        return new subject;
      });
    }
  }</div><div class="out"></div><div class="in">Highlander = (function(_super) {

    __extends(Highlander, _super);

    function Highlander() {
      return Highlander.__super__.constructor.apply(this, arguments);
    }

    Highlander.classMixin(Singleton);

    return Highlander;

  })(Batman.Object)</div><div class="out"></div><div class="in">instance = Highlander.get('instance')</div><div class="out"></div><div class="in">instance === Highlander.get('instance')</div><div class="out">true // There can only be one.</div></code>
  </pre>
</div>
<h3 id="batman-object-observeall">@observeAll(key, callback : function) : prototype</h3>
<p><code>@observeAll</code> extends the <code>Batman.Object</code> implementation of <code>Batman.Observable</code> with the ability to observe all instances of the class (and subclasses). Observers attached with <code>@observeAll</code> function exactly as if they were attached to the object directly. Returns the prototype of the class.

</p>
<p><em>Note</em>: <code>@observeAll</code> is intended to be used during the class definition for a <code>Batman.Object</code> subclass, but it can be called after the class has been defined as a function on the class. It supports being called after instances of the class have been instantiated as well.

</p>
<div class="console-session">
  <h4>@observeAll attaches handlers which get called upon change</h4>
  <pre><code class="javascript"><div class="in">Song = (function(_super) {

    __extends(Song, _super);

    function Song() {
      return Song.__super__.constructor.apply(this, arguments);
    }

    Song.observeAll('length', function(newValue, oldValue) {
      return log(newValue);
    });

    return Song;

  })(Batman.Object)</div><div class="out"></div><div class="in">song = new Song({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.last</div><div class="out">200</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@observeAll can attach handlers after instance instantiation</h4>
  <pre><code class="javascript"><div class="in">Song = (function(_super) {

    __extends(Song, _super);

    function Song() {
      return Song.__super__.constructor.apply(this, arguments);
    }

    return Song;

  })(Batman.Object)</div><div class="out"></div><div class="in">song = new Song({
    length: 340,
    bpm: 120
  })</div><div class="out"></div><div class="in">song.set('length', 360)</div><div class="out">360</div><div class="in">logged.last</div><div class="out">void 0</div><div class="in">Song.observeAll('length', function(newValue, oldValue) {
    return log(newValue);
  })</div><div class="out"></div><div class="in">song.set('length', 200)</div><div class="out">200</div><div class="in">logged.last</div><div class="out">200</div></code>
  </pre>
</div>
<h3 id="batman-object-constructor">constructor(objects...)</h3>
<p>To create a new <code>Batman.Object</code>, the <code>Batman.Object</code> constructor can be used, or, the <code>Batman</code> namespace is also a utility function for creating Batman objects. Each object passed in to the constructor will have all its properties applied to the new <code>Batman.Object</code> using <code>get</code> and <code>set</code>, so any custom getters or setters will be respected. Objects passed in last will have precedence over objects passed in first in the event that they share the same keys. The property copy from these objects is shallow.

</p>
<div class="console-session">
  <h4>Batman() function allows for handy creation of Batman.Objects</h4>
  <pre><code class="javascript"><div class="in">object = Batman({
    foo: 'bar'
  })</div><div class="out"></div><div class="in">typeof object.get</div><div class="out">'function'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Batman.Object constructor function accepts multiple mixin arguments and later mixins take precedence.</h4>
  <pre><code class="javascript"><div class="in">song = Batman({
    length: 100,
    bpm: 120
  }, {
    bpm: 130
  })</div><div class="out"></div><div class="in">song.get('length')</div><div class="out">100</div><div class="in">song.get('bpm')</div><div class="out">130 // The property from the second object passed to the constructor overwrites that from the first.</div></code>
  </pre>
</div>
<h3 id="batman-object-tojson">toJSON() : object</h3>
<p><code>toJSON</code> returns a vanilla JavaScript object representing this <code>Batman.Object</code>.

</p>
<div class="console-session">
  <h4>toJSON returns a vanilla JS object</h4>
  <pre><code class="javascript"><div class="in">object = Batman({
    foo: 'bar'
  })</div><div class="out"></div><div class="in">object.toJSON()</div><div class="out">{
    foo: 'bar'
  }</div></code>
  </pre>
</div>
<h3 id="batman-object-hashkey">hashKey() : string</h3>
<p><code>hashKey</code> returns a unique string identifying this particular <code>Batman.Object</code>. No two <code>Batman.Object</code>s will have the same <code>hashKey</code>. Feel free to override the implmentation of this function on your objects if you have a better hashing scheme for a domain object of yours.

</p>
<h3 id="batman-object-accessor">accessor([keys...], objectOrFunction)</h3>
<p><code>accessor</code> defines an accessor on one instance of an object instead of on all instances like the class level <code>@accessor</code>. See <code>@accessor</code> for the details surrounding accessors.

</p>
<div class="console-session">
  <h4>accessor can be called on an instance of Batman.Object to define an accessor just on that instance</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.accessor('summary', function() {
      return this.get('body').slice(0, 10) + "...";
    });

    return Post;

  })(Batman.Object)</div><div class="out"></div><div class="in">post = new Post({
    body: "Why Batman is Useful: A lengthy post on an important subject"
  })</div><div class="out"></div><div class="in">post.get('summary')</div><div class="out">"Why Batman..."</div><div class="in">post.accessor('longSummary', function() {
    return this.get('body').slice(0, 20) + "...";
  })</div><div class="out"></div><div class="in">post.get('longSummary')</div><div class="out">"Why Batman is Useful..."</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>defining an accessor on an instance does not affect the other instances</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    return Post;

  })(Batman.Object)</div><div class="out"></div><div class="in">post = new Post({
    body: "Why Batman is Useful: A lengthy post on an important subject"
  })</div><div class="out"></div><div class="in">otherPost = new Post({
    body: "Why State Machines Are Useful: Another lengthy post"
  })</div><div class="out"></div><div class="in">post.accessor('longSummary', function() {
    return this.get('body').slice(0, 20) + "...";
  })</div><div class="out"></div><div class="in">post.get('longSummary')</div><div class="out">"Why Batman is Useful..."</div><div class="in">otherPost.get('longSummary')</div><div class="out">void 0</div></code>
  </pre>
</div>
<h3 id="batman-object-mixin">mixin(objects...) : this</h3>
<p><code>mixin</code> extends the object it&#39;s called on with the passed <code>objects</code> using the <code>Batman.mixin</code> helper. Returns the object it&#39;s called upon.

</p>
<p><em>Note</em>: Since the <code>Batman.mixin</code> helper is used, mixin functionality like using <code>set</code> to apply properties and calling <code>initialize</code> functions is included in the instance level <code>mixin</code> function.

</p>
<div class="console-session">
  <h4>mixin on an instance applies the keys from the mixed in object to the instance</h4>
  <pre><code class="javascript"><div class="in">Snake = (function(_super) {

    __extends(Snake, _super);

    function Snake() {
      return Snake.__super__.constructor.apply(this, arguments);
    }

    return Snake;

  })(Batman.Object)</div><div class="out"></div><div class="in">snake = new Snake()</div><div class="out"></div><div class="in">snake.mixin({
    canSlither: true
  }, {
    canHiss: true
  })</div><div class="out"></div><div class="in">snake.get('canSlither')</div><div class="out">true</div><div class="in">snake.get('canHiss')</div><div class="out">true</div></code>
  </pre>
</div>

<h2 id="batman-simpleset">Batman.SimpleSet</h2>
<p><code>SimpleSet</code> is an implementation of the <code>Set</code> object you might expect to find in lots of other languages standard libraries. Sets are an enumerable but unordered collection of objects. A particular object may either be a member or not be a member of a particular set, but it may not belong to the set twice, as that would imply ordering. In the case of Batman, sets will tell you when items are added or removed through events, sets mix in the <code>Enumerable</code> module for handy iteration and aggregation, and can also generate indexes and sorts via <code>SetIndex</code> and <code>SetSort</code>.

</p>
<h4 id="batman-simpleset-simpleset-vs-set">SimpleSet vs Set</h4>
<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the set semantics as described above, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) can not be observed, and thus not bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nice with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact correct, consider using a native array as well, because iteration and in fact membership checks will be faster.


</p>
<h3 id="batman-simpleset-constructor">constructor(items...)</h3>
<p>When creating a <code>SimpleSet</code>, items forming the initial set can be passed as separate arguments to the constructor

</p>
<div class="console-session">
  <h4>new SimpleSet constructor can be called without arguments</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet</div><div class="out"></div><div class="in">set.toArray()</div><div class="out">[]</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>new SimpleSet constructor can be passed items to add to the set.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b', 'c')</div><div class="out"></div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-length">length : number</h3>
<p>A count of the items in a <code>SimpleSet</code> can be found at its <code>length</code> property.

</p>
<h3 id="batman-simpleset-has">has(item) : Boolean</h3>
<p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.

</p>
<div class="console-session">
  <h4>SimpleSet::has indicates if an item is a member of the set or not.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b', 'c')</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">true</div><div class="in">set.has('d')</div><div class="out">false</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-add">add(items...) : Array</h3>
<p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set itself before addition.

</p>
<div class="console-session">
  <h4>SimpleSet::add adds an item to the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet()</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">false</div><div class="in">set.add('a')</div><div class="out">['a']</div><div class="in">set.has('a')</div><div class="out">true</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>SimpleSet::add returns only the new items that weren\&#39;t previously in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b')</div><div class="out"></div><div class="in">set.add('b', 'c', 'd').sort()</div><div class="out">['c', 'd']</div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c', 'd']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-remove">remove(items...) : Array</h3>
<p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.

</p>
<div class="console-session">
  <h4>SimpleSet::remove removes an item from the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a')</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">true</div><div class="in">set.remove('a')</div><div class="out">['a']</div><div class="in">set.has('a')</div><div class="out">false</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>SimpleSet::remove returns only the new items that were previously in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b')</div><div class="out"></div><div class="in">set.remove('b', 'c', 'd').sort()</div><div class="out">['b']</div><div class="in">set.toArray()</div><div class="out">['a']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-find">find(testFunction : function) : [Object]</h3>
<p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.

</p>
<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.


</p>
<div class="console-session">
  <h4>SimpleSet::find returns the first item for which the test function passes</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet(1, 2, 3)</div><div class="out"></div><div class="in">set.find(function(x) {
    return x % 2 === 0;
  })</div><div class="out">2</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>SimpleSet::find returns undefined if no items pass the test function</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet(1, 2, 3)</div><div class="out"></div><div class="in">typeof set.find(function(x) {
    return x > 5;
  })</div><div class="out">'undefined'</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-foreach">forEach(iteratorFunction : function[, context: Object])</h3>
<p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.

</p>
<p><em>Note</em>: Set iteration order is not defined, which is to say Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.

</p>
<div class="console-session">
  <h4>SimpleSet::forEach iterates over each item in the set</h4>
  <pre><code class="javascript"><div class="in">sum = 0</div><div class="out"></div><div class="in">set = new Batman.SimpleSet(1, 2, 3)</div><div class="out"></div><div class="in">set.forEach(function(x) {
    return sum += x;
  })</div><div class="out"></div><div class="in">sum</div><div class="out">6</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>SimpleSet::forEach iterates over each item in the set optionally in the provided context</h4>
  <pre><code class="javascript"><div class="in">context = {
    sum: 0
  }</div><div class="out"></div><div class="in">set = new Batman.SimpleSet(1, 2, 3)</div><div class="out"></div><div class="in">set.forEach(function(x) {
    return this.sum += x;
  }, context)</div><div class="out"></div><div class="in">context.sum</div><div class="out">6</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-isempty">isEmpty() : boolean</h3>
<p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.

</p>
<div class="console-session">
  <h4>SimpleSet::isEmpty returns true if the set has no items</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet()</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">true</div><div class="in">set.add('a')</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">false</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-clear">clear() : Array</h3>
<p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.

</p>
<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.

</p>
<div class="console-session">
  <h4>SimpleSet::clear empties the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b', 'c')</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">false</div><div class="in">set.clear().sort()</div><div class="out">['a', 'b', 'c']</div><div class="in">set.isEmpty()</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-replace">replace(collection : Enumerable) : Array</h3>
<p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.

</p>
<div class="console-session">
  <h4>SimpleSet::replace empties the set and then adds items from a different collection</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet('a', 'b', 'c')</div><div class="out"></div><div class="in">secondSet = new Batman.SimpleSet('d', 'e', 'f')</div><div class="out"></div><div class="in">set.replace(secondSet).sort()</div><div class="out">['d', 'e', 'f']</div><div class="in">set.toArray().sort()</div><div class="out">['d', 'e', 'f']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-toarray">toArray() : Array</h3>
<p><code>toArray</code> returns an array representation of the set.

</p>
<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.

</p>
<div class="console-session">
  <h4>SimpleSet::toArray returns an array representation of the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet()</div><div class="out"></div><div class="in">set.toArray()</div><div class="out">[]</div><div class="in">set.add('a', 'b', 'c')</div><div class="out"></div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-merge">merge(collections... : Enumerable) : SimpleSet</h3>
<p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.

</p>
<div class="console-session">
  <h4>SimpleSet::merge returns a new set with the items of the original set and the passed set</h4>
  <pre><code class="javascript"><div class="in">abc = new Batman.SimpleSet('a', 'b', 'c')</div><div class="out"></div><div class="in">def = new Batman.SimpleSet('d', 'e', 'f')</div><div class="out"></div><div class="in">Batman.typeOf(set = abc.merge(def))</div><div class="out">'Object'</div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c', 'd', 'e', 'f']</div></code>
  </pre>
</div>
<h3 id="batman-simpleset-indexedby">indexedBy(key : String) : SetIndex</h3>
<p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.

</p>
<div class="console-session">
  <h4>SimpleSet::indexedBy returns a new SetIndex with the items bucketed by the value of the key</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.SimpleSet(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }), Batman({
    colour: 'blue'
  }))</div><div class="out"></div><div class="in">index = set.indexedBy('colour')</div><div class="out"></div><div class="in">index.get('blue') instanceof Batman.Set</div><div class="out">true</div><div class="in">index.get('blue').get('length')</div><div class="out">2</div><div class="in">index.get('green').get('length')</div><div class="out">1</div></code>
  </pre>
</div>
<p><em>Note</em>: <code>SetIndex</code> on <code>SimpleSet</code> can&#39;t maintain up-to-datedness as the state of the set or items change. It can on a bonified <code>Set</code> however, so if you need a <code>SetIndex</code> which will be guaranteed up to date as items in the set change or the values of the observed <code>key</code> change on items, use a <code>Set</code> and <code>Set::indexedBy</code> instead of <code>SimpleSet::indexedBy</code>.

</p>
<h3 id="batman-simpleset-indexedbyunique">indexedByUnique(key : String) : UniqueSetIndex</h3>
<p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.

</p>
<div class="console-session">
  <h4>SimpleSet::indexedByUnique returns a new UniqueSetIndex with the items hashed by the value of the key</h4>
  <pre><code class="javascript"><div class="in">greenItem = Batman({
    colour: 'green'
  })</div><div class="out"></div><div class="in">blueItem = Batman({
    colour: 'blue'
  })</div><div class="out"></div><div class="in">set = new Batman.SimpleSet(greenItem, blueItem)</div><div class="out"></div><div class="in">index = set.indexedByUnique('colour')</div><div class="out"></div><div class="in">blueItem === index.get('blue')</div><div class="out">true</div><div class="in">greenItem === index.get('green')</div><div class="out">true</div><div class="in">void 0</div><div class="out">index.get('red')</div></code>
  </pre>
</div>
<p><em>Note</em>: <code>SetIndex</code> on <code>SimpleSet</code> can&#39;t maintain up-to-datedness as the state of the set or items change. It can on a bonified <code>Set</code> however, so if you need a <code>SetIndex</code> which will be guaranteed up to date as items in the set change or the values of the observed <code>key</code> change on items, use a <code>Set</code> and <code>Set::indexedBy</code> instead of <code>SimpleSet::indexedBy</code>.

</p>
<h3 id="batman-simpleset-sortedby">sortedBy(key: String) : SetSort</h3>

<h2 id="batman-set">Batman.Set</h2>
<p><code>Set</code> is an observable, <code>Batman.Object</code> wrapper around <code>SimpleSet</code>.

</p>
<h4 id="batman-set-simpleset-vs-set">SimpleSet vs Set</h4>
<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the basic set semantics, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) can not be bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nice with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact correct, consider using a native array as well, because iteration and in fact membership checks will be faster.

</p>
<h3 id="batman-set-constructor">constructor(items...)</h3>
<p>When creating a <code>Set</code>, items forming the initial set can be passed as separate arguments to the constructor

</p>
<div class="console-session">
  <h4>new Set constructor can be called without arguments</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set</div><div class="out"></div><div class="in">set.toArray()</div><div class="out">[]</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>new Set constructor can be passed items to add to the set.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-set-length">length : number</h3>
<p>A count of the items in a <code>Set</code> can be found at its <code>length</code> property.

</p>
<h3 id="batman-set-isempty">isEmpty : boolean</h3>
<p>Observable property for <code>isEmpty()</code>

</p>
<h3 id="batman-set-toarray">toArray : Array</h3>
<p>Observable property for <code>toArray()</code>. Whenever items are added or removed on the set, the <code>toArray</code> property will change. This is the mechanism by which Batman&#39;s view bindings get notified of collection updates.

</p>
<div class="console-session">
  <h4>observers on the toArray property fire when the set changes</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.observe('toArray', function(newArray) {
    return log(newArray.sort());
  })</div><div class="out"></div><div class="in">set.add('d')</div><div class="out">['d']</div><div class="in">logged.last</div><div class="out">['a', 'b', 'c', 'd']</div><div class="in">set.remove('b')</div><div class="out">['b']</div><div class="in">logged.last</div><div class="out">['a', 'c', 'd']</div></code>
  </pre>
</div>
<h3 id="batman-set-has">has(item) : Boolean</h3>
<p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.

</p>
<p><em>Note</em>: Using <code>has(item)</code> in an accessor body will register the set <code>has</code> is called upon as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated, because the set may now have or not have the item in question.

</p>
<div class="console-session">
  <h4>Set::has indicates if an item is a member of the set or not.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">true</div><div class="in">set.has('d')</div><div class="out">false</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::has registers the set as a source of an accessor</h4>
  <pre><code class="javascript"><div class="in">(Team = (function(_super) {

    __extends(Team, _super);

    function Team() {
      this.awards = new Batman.Set();
    }

    Team.accessor('bestEver?', function() {
      return this.get('awards').has('Stanley Cup');
    });

    return Team;

  })(Batman.Object))</div><div class="out"></div><div class="in">team = new Team</div><div class="out"></div><div class="in">team.observeAndFire('bestEver?', function(status) {
    return log(status);
  })</div><div class="out"></div><div class="in">team.get('awards').add('Eastern Conference Champs')</div><div class="out"></div><div class="in">logged.last</div><div class="out">false</div><div class="in">team.get('awards').add('Stanley Cup')</div><div class="out"></div><div class="in">logged.last</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-set-add">add(items...)</h3>
<p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set itself before addition.

</p>
<p><code>add</code> fires the <code>itemsWereAdded</code> event with the list of items newly added to the set if that list has length greater than 0. This is to say the event will not be fired if the items passed to add were all already members of the set.

</p>
<div class="console-session">
  <h4>Set::add adds an item to the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set()</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">false</div><div class="in">set.add('a')</div><div class="out">['a']</div><div class="in">set.has('a')</div><div class="out">true</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::add returns only the new items that weren\&#39;t previously in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b')</div><div class="out"></div><div class="in">set.add('b', 'c', 'd').sort()</div><div class="out">['c', 'd']</div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c', 'd']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::add fires the itemsWereAdded event with the items newly added to the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b')</div><div class="out"></div><div class="in">set.on('itemsWereAdded', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.add('b', 'c', 'd')</div><div class="out"></div><div class="in">logged.last.sort()</div><div class="out">['c', 'd']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::add does not fire the itemsWereAdded event if the added items were already in the set.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b')</div><div class="out"></div><div class="in">set.on('itemsWereAdded', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.add('a', 'b')</div><div class="out"></div><div class="in">typeof logged.last</div><div class="out">'undefined'</div></code>
  </pre>
</div>
<h3 id="batman-set-remove">remove(items...)</h3>
<p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.

</p>
<p><code>remove</code> fires the <code>itemsWereRemoved</code> event with the list of removed items if that list has length greater than 0. This is to say the event will not be fired if none of the passed items were members of the set.

</p>
<div class="console-session">
  <h4>Set::remove removes an item from the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a')</div><div class="out"></div><div class="in">set.has('a')</div><div class="out">true</div><div class="in">set.remove('a')</div><div class="out">['a']</div><div class="in">set.has('a')</div><div class="out">false</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::remove returns only the new items that were previously in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b')</div><div class="out"></div><div class="in">set.remove('b', 'c', 'd').sort()</div><div class="out">['b']</div><div class="in">set.toArray()</div><div class="out">['a']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::remove fires the itemsWereRemoved event with the items removed to the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.on('itemsWereRemoved', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.remove('b', 'c')</div><div class="out"></div><div class="in">logged.last.sort()</div><div class="out">['b', 'c']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::remove does not fire the itemsWereRemoved event if the removed items were not already members of the set.</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b')</div><div class="out"></div><div class="in">set.on('itemsWereRemoved', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.remove('c', 'd')</div><div class="out"></div><div class="in">typeof logged.last</div><div class="out">'undefined'</div></code>
  </pre>
</div>
<h3 id="batman-set-find">find(testFunction : function) : [Object]</h3>
<p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.

</p>
<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.


</p>
<div class="console-session">
  <h4>Set::find returns the first item for which the test function passes</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(1, 2, 3)</div><div class="out"></div><div class="in">set.find(function(x) {
    return x % 2 === 0;
  })</div><div class="out">2</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::find returns undefined if no items pass the test function</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(1, 2, 3)</div><div class="out"></div><div class="in">typeof set.find(function(x) {
    return x > 5;
  })</div><div class="out">'undefined'</div></code>
  </pre>
</div>
<h3 id="batman-set-foreach">forEach(iteratorFunction : function[, context: Object])</h3>
<p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.

</p>
<p><em>Note</em>: Set iteration order is not defined, which is to say Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.

</p>
<p><em>Note</em>: Using <code>forEach()</code> in an accessor body will register the set iterated over as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated. This can become an issue if you iterate over a set and modify the set&#39;s items, as when the property recalculates that modification will potentially happen on items it&#39;s happened on previously.

</p>
<div class="console-session">
  <h4>Set::forEach iterates over each item in the set</h4>
  <pre><code class="javascript"><div class="in">sum = 0</div><div class="out"></div><div class="in">set = new Batman.Set(1, 2, 3)</div><div class="out"></div><div class="in">set.forEach(function(x) {
    return sum += x;
  })</div><div class="out"></div><div class="in">sum</div><div class="out">6</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::forEach iterates over each item in the set optionally in the provided context</h4>
  <pre><code class="javascript"><div class="in">context = {
    sum: 0
  }</div><div class="out"></div><div class="in">set = new Batman.Set(1, 2, 3)</div><div class="out"></div><div class="in">set.forEach(function(x) {
    return this.sum += x;
  }, context)</div><div class="out"></div><div class="in">context.sum</div><div class="out">6</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::forEach registers the set as a source if called in an accessor body</h4>
  <pre><code class="javascript"><div class="in">(Team = (function(_super) {

    __extends(Team, _super);

    function Team() {
      this.players = new Batman.Set();
    }

    Team.accessor('willWinTheCup?', function() {
      var sedinCount;
      sedinCount = 0;
      this.players.forEach(function(player) {
        if (player.split(' ')[1] === 'Sedin') {
          return sedinCount++;
        }
      });
      return sedinCount >= 2;
    });

    return Team;

  })(Batman.Object))</div><div class="out"></div><div class="in">team = new Team()</div><div class="out"></div><div class="in">team.observeAndFire('willWinTheCup?', function(status) {
    return log(status);
  })</div><div class="out"></div><div class="in">team.get('willWinTheCup?')</div><div class="out">false</div><div class="in">team.get('players').add('Henrik Sedin')</div><div class="out"></div><div class="in">logged.last</div><div class="out">false</div><div class="in">team.get('players').add('Daniel Sedin')</div><div class="out"></div><div class="in">logged.last</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-set-isempty">isEmpty() : boolean</h3>
<p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.

</p>
<p><em>Note</em>: Using <code>isEmpty()</code> in an accessor body will register the set <code>isEmpty</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.

</p>
<div class="console-session">
  <h4>Set::isEmpty returns true if the set has no items</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set()</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">true</div><div class="in">set.add('a')</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">false</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::isEmpty registers the set as a source of an accessor</h4>
  <pre><code class="javascript"><div class="in">(Team = (function(_super) {

    __extends(Team, _super);

    function Team() {
      this.games = new Batman.Set();
    }

    Team.accessor('seasonStarted?', function() {
      return !this.games.isEmpty();
    });

    return Team;

  })(Batman.Object))</div><div class="out"></div><div class="in">team = new Team</div><div class="out"></div><div class="in">team.get('seasonStarted?')</div><div class="out">false</div><div class="in">team.get('games').add({
    win: true
  })</div><div class="out"></div><div class="in">team.get('seasonStarted?')</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-set-clear">clear() : Array</h3>
<p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.

</p>
<p><code>clear</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set.

</p>
<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.

</p>
<div class="console-session">
  <h4>Set::clear empties the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.isEmpty()</div><div class="out">false</div><div class="in">set.clear().sort()</div><div class="out">['a', 'b', 'c']</div><div class="in">set.isEmpty()</div><div class="out">true</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::clear fires the itemsWereRemoved event with all the items in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.on('itemsWereRemoved', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.clear()</div><div class="out"></div><div class="in">logged.last.sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-set-replace">replace(collection : Enumerable) : Array</h3>
<p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.

</p>
<p><code>replace</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set, and then the <code>itemsWereAdded</code> event once with the items from the incoming collection.

</p>
<div class="console-session">
  <h4>Set::replace empties the set and then adds items from a different collection</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">secondSet = new Batman.Set('d', 'e', 'f')</div><div class="out"></div><div class="in">set.replace(secondSet).sort()</div><div class="out">['d', 'e', 'f']</div><div class="in">set.toArray().sort()</div><div class="out">['d', 'e', 'f']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::replace fires the itemsWereRemoved event with all the items in the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">set.on('itemsWereRemoved', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.replace(new Batman.SimpleSet())</div><div class="out"></div><div class="in">logged.last.sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::replace fires the itemsWereAdded event with all the items in the incoming set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set()</div><div class="out"></div><div class="in">set.on('itemsWereAdded', function() {
    var items;
    items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return log(items);
  })</div><div class="out"></div><div class="in">set.replace(new Batman.SimpleSet('a', 'b', 'c'))</div><div class="out"></div><div class="in">logged.last.sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-set-toarray">toArray() : Array</h3>
<p><code>toArray</code> returns an array representation of the set.

</p>
<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.

</p>
<p><em>Note</em>: <code>toArray</code> is also an observable property.

</p>
<p><em>Note</em>: Using <code>toArray()</code> in an accessor body will register the set <code>toArray</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.

</p>
<div class="console-session">
  <h4>Set::toArray returns an array representation of the set</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set()</div><div class="out"></div><div class="in">set.toArray()</div><div class="out">[]</div><div class="in">set.add('a', 'b', 'c')</div><div class="out"></div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c']</div></code>
  </pre>
</div>
<h3 id="batman-set-merge">merge(collections... : Enumerable) : Set</h3>
<p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.

</p>
<p><em>Note</em>: Be careful about using <code>merge</code> within accessors. Calling <code>merge</code> in an accessor function body will register the set <code>merge</code> is called upon as a source of the property being calculated, which means when the set changes, that accessor will be recalculated. This means the O(n * m) merge will occur again each time, and return an entirely new <code>Set</code> instance. If the previously returned <code>Set</code> instance is retained after recalculation, this is a big memory leak. Instead of merging in accessors, try to use a <code>SetUnion</code> or a <code>SetIntersection</code>.

</p>
<div class="console-session">
  <h4>Set::merge returns a new set with the items of the original set and the passed set</h4>
  <pre><code class="javascript"><div class="in">abc = new Batman.Set('a', 'b', 'c')</div><div class="out"></div><div class="in">def = new Batman.Set('d', 'e', 'f')</div><div class="out"></div><div class="in">Batman.typeOf(set = abc.merge(def))</div><div class="out">'Object'</div><div class="in">set.toArray().sort()</div><div class="out">['a', 'b', 'c', 'd', 'e', 'f']</div></code>
  </pre>
</div>
<h3 id="batman-set-indexedby">indexedBy(key : String) : SetIndex</h3>
<p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.

</p>
<div class="console-session">
  <h4>Set::indexedBy returns a new SetIndex with the items bucketed by the value of the key</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }), Batman({
    colour: 'blue'
  }))</div><div class="out"></div><div class="in">index = set.indexedBy('colour')</div><div class="out"></div><div class="in">index.get('blue') instanceof Batman.Set</div><div class="out">true</div><div class="in">index.get('blue').get('length')</div><div class="out">2</div><div class="in">index.get('green').get('length')</div><div class="out">1</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::indexedBy returns a new SetIndex which observes the set for new additions and stays up to date</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }))</div><div class="out"></div><div class="in">index = set.indexedBy('colour')</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">1</div><div class="in">newItem = Batman({
    colour: 'blue'
  })</div><div class="out"></div><div class="in">set.add(newItem)</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">2</div><div class="in">index.get('blue').has(newItem)</div><div class="out">true</div><div class="in">set.remove(newItem)</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">1</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::indexedBy returns a new SetIndex which observes the items in the set for changes to the observed key</h4>
  <pre><code class="javascript"><div class="in">itemA = Batman({
    colour: 'blue'
  })</div><div class="out"></div><div class="in">itemB = Batman({
    colour: 'green'
  })</div><div class="out"></div><div class="in">set = new Batman.Set(itemA, itemB)</div><div class="out"></div><div class="in">index = set.indexedBy('colour')</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">1</div><div class="in">index.get('green').get('length')</div><div class="out">1</div><div class="in">itemA.set('colour', 'green')</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">0</div><div class="in">index.get('green').get('length')</div><div class="out">2</div></code>
  </pre>
</div>
<p><code>SetIndex</code>es can be created by calling the <code>indexedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedBy</code> property.

</p>
<div class="console-session">
  <h4>Set::get(&#39;indexedBy.someKey&#39;) returns a new SetIndex for &#39;someKey&#39;</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }))</div><div class="out"></div><div class="in">index = set.get('indexedBy.colour')</div><div class="out"></div><div class="in">index.get('blue').get('length')</div><div class="out">1</div></code>
  </pre>
</div>
<h3 id="batman-set-indexedbyunique">indexedByUnique(key : String) : UniqueSetIndex</h3>
<p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.

</p>
<div class="console-session">
  <h4>Set::indexedByUnique returns a new UniqueSetIndex with the items hashed by the value of the key</h4>
  <pre><code class="javascript"><div class="in">greenItem = Batman({
    colour: 'green'
  })</div><div class="out"></div><div class="in">blueItem = Batman({
    colour: 'blue'
  })</div><div class="out"></div><div class="in">set = new Batman.Set(greenItem, blueItem)</div><div class="out"></div><div class="in">index = set.indexedByUnique('colour')</div><div class="out"></div><div class="in">blueItem === index.get('blue')</div><div class="out">true</div><div class="in">greenItem === index.get('green')</div><div class="out">true</div><div class="in">void 0</div><div class="out">index.get('red')</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::indexedByUnique returns a new UniqueSetIndex which observes the set for new additions and stays up to date</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }))</div><div class="out"></div><div class="in">index = set.indexedByUnique('colour')</div><div class="out"></div><div class="in">newItem = Batman({
    colour: 'red'
  })</div><div class="out"></div><div class="in">set.add(newItem)</div><div class="out"></div><div class="in">newItem === index.get('red')</div><div class="out">true</div><div class="in">set.remove(newItem)</div><div class="out"></div><div class="in">void 0</div><div class="out">index.get('red')</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>Set::indexedByUnique returns a new UniqueSetIndex which observes the items in the set for changes to the observed key</h4>
  <pre><code class="javascript"><div class="in">itemA = Batman({
    colour: 'blue'
  })</div><div class="out"></div><div class="in">itemB = Batman({
    colour: 'green'
  })</div><div class="out"></div><div class="in">set = new Batman.Set(itemA, itemB)</div><div class="out"></div><div class="in">index = set.indexedByUnique('colour')</div><div class="out"></div><div class="in">index.get('blue') != null</div><div class="out">true</div><div class="in">index.get('green') != null</div><div class="out">true</div><div class="in">index.get('red') != null</div><div class="out">false</div><div class="in">itemA.set('colour', 'red')</div><div class="out"></div><div class="in">index.get('blue') != null</div><div class="out">false</div><div class="in">index.get('green') != null</div><div class="out">true</div><div class="in">index.get('red') != null</div><div class="out">true</div></code>
  </pre>
</div>
<p><code>UniqueSetIndex</code>es can be created by calling the <code>indexedByUnique</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedByUnique</code> property.

</p>
<div class="console-session">
  <h4>Set::get(&#39;indexedByUnique.someKey&#39;) returns a new UniqueSetIndex for &#39;someKey&#39;</h4>
  <pre><code class="javascript"><div class="in">set = new Batman.Set(Batman({
    colour: 'blue'
  }), Batman({
    colour: 'green'
  }))</div><div class="out"></div><div class="in">index = set.get('indexedByUnique.colour')</div><div class="out"></div><div class="in">'blue'</div><div class="out">index.get('blue').get('colour')</div></code>
  </pre>
</div>
<h3 id="batman-set-sortedby">sortedBy(key: String) : SetSort</h3>




<h2 id="batman-app">Batman.App</h2>
<p><code>Batman.App</code> is the central object in any Batman application. It manages the routing table and the current URL parameters, as well as the initial start of the application. It should also be used as a namespace for models and views so that other objects can find them. Batman assumes that there will only ever be one <code>Batman.App</code> in use at once.

</p>
<h3 id="batman-app-batman-currentapp">Batman.currentApp</h3>
<p>A Batman-wide reference to the currently running <code>Batman.App</code>.

</p>
<h3 id="batman-app-run">@run() : App</h3>
<p><code>App.run</code> is the central entry point for a Batman application. <code>@run</code> takes these steps to initialize a Batman application:

</p>
<ol>
<li>Instantiate a <code>Dispatcher</code>, an internal object for mananging action dispatch to controllers.</li>
<li>Instantiate a <code>Navigator</code>, an internal object for managing the URL via pushState or hashbangs.</li>
<li>Instantiate the <code>layout</code> view according to the <code>layout</code> property on the <code>App</code>.</li>
<li>Wait for the layout view to fire it&#39;s <code>ready</code> event.</li>
<li>Start the first action dispatch by telling the <code>Navigator</code> to begin monitoring the URL.</li>
</ol>
<p><em>Note</em>: <code>@run</code> emits the <code>run</code> class event on the <code>App</code>, but not necessarily as soon as <code>@run</code> is called. Because the <code>layout</code> View renders asynchronously and may need to fetch other components, the <code>run</code> event can and often does fire long after <code>@run</code> is called. If you need to execute code as soon as the <code>App</code> has started running, add a listener to the <code>run</code> event on the <code>App</code> class. If you need to execute code as soon as the layout has rendered, you can use the <code>ready</code> event on the <code>App</code> class.

</p>
<p><code>@run</code> can be called before or on the <code>load</code> DOMEvent of the window. <code>@run</code> will return the App if the commencement was successful and complete, or <code>false</code> if the App must wait for the <code>layout</code> to render or if the <code>App</code> has already run.

</p>
<h4 id="batman-app-run-starting-an-application-with-domevents">starting an application with DOMEvents</h4>
<pre><code class="coffeescript">window.addEventListener 'load', ->
  MyApp.run()</code></pre>
<h4 id="batman-app-run-starting-an-application-with-jquery">starting an application with jQuery</h4>
<pre><code class="coffeescript">$ ->
  MyApp.run()</code></pre>
<h3 id="batman-app-stop">@stop() : App</h3>
<p><code>@stop</code> stops the <code>App</code> it&#39;s called upon. The URL will stop being monitored and no more actions will be dispatched. In usual Batman development you shouldn&#39;t have to call this.

</p>
<h3 id="batman-app-routes">@routes</h3>
<p><code>@routes</code> is a class level property referencing the root level <code>NamedRouteQuery</code> which allows for binding to routes on objects. See <code>data-route</code> bindings for more information.

</p>
<h3 id="batman-app-controllers">@controllers</h3>
<p><code>@controllers</code> is a class level property containing the singleton <code>Batman.Controller</code> instances for each subclass in the application. This <code>controllers</code> directory puts these instances at the lowercase name of the controller. For example, the <code>TodosController</code> would be found at <code>controllers.todos</code>. <code>@controllers</code> ideally should never be bound to, but it is very useful for debugging in the console and other such workarounds.

</p>
<div class="console-session">
  <h4>App.controllers references a directory of controller instances</h4>
  <pre><code class="javascript"><div class="in">Alfred = (function(_super) {

    __extends(Alfred, _super);

    function Alfred() {
      return Alfred.__super__.constructor.apply(this, arguments);
    }

    return Alfred;

  })(Batman.App)</div><div class="out"></div><div class="in">Alfred.TodosController = (function(_super) {

    __extends(TodosController, _super);

    function TodosController() {
      return TodosController.__super__.constructor.apply(this, arguments);
    }

    return TodosController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = Alfred.get('controllers.todos')</div><div class="out"></div><div class="in">Batman._functionName(controller.constructor)</div><div class="out">"TodosController"</div></code>
  </pre>
</div>
<h3 id="batman-app-layout">@layout</h3>
<h3 id="batman-app-currentparams">@currentParams</h3>
<h3 id="batman-app-paramsmanager">@paramsManager</h3>
<h3 id="batman-app-paramspusher">@paramsPusher</h3>
<h3 id="batman-app-run-class-event">&#39;run&#39; class event</h3>
<p>The <code>run</code> class event is fired once the app has run. This indeterminately but often happens before the app&#39;s layout has finished rendering.

</p>
<h3 id="batman-app-ready-class-event">&#39;ready&#39; class event</h3>
<p>The <code>ready</code> class event is fired once the app&#39;s layout is rendered.

</p>
<h2 id="batman-app-routing">Batman.App Routing</h2>
<p>The <code>Batman</code> routing DSL is similar to Rails 3&#39;s routing DSL.

</p>
<h3 id="batman-app-routing-resources">@resources</h3>
<h3 id="batman-app-routing-member">@member</h3>
<h3 id="batman-app-routing-collection">@collection</h3>
<h3 id="batman-app-routing-route">@route</h3>
<h3 id="batman-app-routing-root">@root</h3>

<h2 id="batman-controller">Batman.Controller</h2>
<p><code>Batman.Controller</code> is the base class from which all an application&#39;s controllers should descend from. <code>Batman.Controllers</code> are responsible for executing <em>actions</em> which fire off requests for model data, render views, or redirect to other actions in response to navigation state changes.

</p>
<h3 id="batman-controller-controller-directory">Controller Directory</h3>
<p><code>Batman.Controller</code>s are singletons which means each controller in your application is instantiated exactly once. The instance of each controller is available on the class at the <code>@sharedContoller</code> property, or within a <code>ControllerDirectory</code> on the <code>Application</code> class. See <code>Batman.Application.controllers</code>.

</p>
<h3 id="batman-controller-actions">Actions</h3>
<p>Each <code>Batman.Controller</code> should have a number of instance level functions which can fetch the data needed and often render a view (or views) to display that data. These functions can be declared in typical CoffeeScript fashion like so:

</p>
<pre><code class="coffeescript">class Alfred.TodosController

  index: (params) ->

  show: (params) -></code></pre>
<p>Each action function receives the parameters from the dispatcher which are pulled out of the navigated-to URL. This includes both named route parameters (<code>/:foo</code> style) as well as arbitrary query paramters (<code>?foo=bar</code> style).

</p>
<h3 id="batman-controller-routingkey-and-minification"><code>routingKey</code> and Minification</h3>
<p>For functionality like contextual redirects and automatic view source and class inference, Batman needs to know the name of all your <code>Controller</code> subclasses. The usual way to do this is by using <code>Function::name</code> which Batman will use in development, but this is often mangled in minified production environments. For this reason, Batman will error out on boot if a <code>Controller</code> subclass&#39; <code>routingKey</code> is not defined on the prototype. The <code>routingKey</code> is a <code>String</code> which remains unmangled after minification and thus allows Batman to continue using the aforementioned features. To disable this requirement (if you know your code won&#39;t ever be minified), set <code>Batman.config.minificationErrors</code> to false.

</p>
<h3 id="batman-controller-beforefilter">@beforeFilter([options : [String|Object]], filter : [String|Function])</h3>
<p><code>@beforeFilter</code> allows controllers to declare that a function should be executed before the body of an action during action execution. <code>@beforeFilter</code> optionally accepts some options representing which action(s) to execute the filter before, and then a string naming a function or function proper to execute.

</p>
<p>The <code>options</code> argument can take three forms to imply different things:

</p>
<ol>
<li><code>undefined</code>: implies that this filter function should be executed before all actions.</li>
<li>a String: implies that this filter function should be executed before the action named by the string.</li>
<li>an Object: implies that this filter function should be executed before the actions named by an Array at the <code>only</code> key in the options object, or before all actions excluding those named by an Array at the <code>except</code> key in the options object.</li>
</ol>
<div class="console-session">
  <h4>@beforeFilter allows declaration of filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TestController = (function(_super) {

    __extends(TestController, _super);

    function TestController() {
      return TestController.__super__.constructor.apply(this, arguments);
    }

    TestController.beforeFilter('index', function() {
      return log('before!');
    });

    TestController.prototype.index = function() {
      log('action!');
      return this.render(false);
    };

    return TestController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TestController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged[0]</div><div class="out">'before!'</div><div class="in">logged[1]</div><div class="out">'action!'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@beforeFilter allows declaration of named filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TodoController = (function(_super) {

    __extends(TodoController, _super);

    function TodoController() {
      return TodoController.__super__.constructor.apply(this, arguments);
    }

    TodoController.beforeFilter('show', 'fetchTodo');

    TodoController.prototype.fetchTodo = function() {
      return this.set('todo', {
        isDone: true
      });
    };

    TodoController.prototype.show = function() {
      return this.render(false);
    };

    return TodoController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TodoController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('show')</div><div class="out"></div><div class="in">controller.get('todo')</div><div class="out">{
    isDone: true
  }</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@beforeFilter allows whitelisting or blacklisting filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TodoController = (function(_super) {

    __extends(TodoController, _super);

    function TodoController() {
      return TodoController.__super__.constructor.apply(this, arguments);
    }

    TodoController.beforeFilter({
      only: ['show', 'edit']
    }, 'fetchTodo');

    TodoController.beforeFilter({
      except: ['index']
    }, 'prepareNewTodo');

    TodoController.prototype.fetchTodo = function() {
      return this.set('todo', {
        isDone: true
      });
    };

    TodoController.prototype.prepareNewTodo = function() {
      return this.set('newTodo', {
        isDone: false
      });
    };

    TodoController.prototype.index = function() {
      return this.render(false);
    };

    TodoController.prototype.show = function() {
      return this.render(false);
    };

    return TodoController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TodoController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('show')</div><div class="out"></div><div class="in">controller.get('todo')</div><div class="out">{
    isDone: true
  }</div><div class="in">controller.get('newTodo')</div><div class="out">{
    isDone: false
  }</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@beforeFilter allows declaration of filters to execute before all actions</h4>
  <pre><code class="javascript"><div class="in">TestController = (function(_super) {

    __extends(TestController, _super);

    function TestController() {
      return TestController.__super__.constructor.apply(this, arguments);
    }

    TestController.beforeFilter(function() {
      return log('before!');
    });

    TestController.prototype.index = function() {
      log('action!');
      return this.render(false);
    };

    return TestController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TestController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged[0]</div><div class="out">'before!'</div><div class="in">logged[1]</div><div class="out">'action!'</div></code>
  </pre>
</div>
<h3 id="batman-controller-afterfilter">@afterFilter([options : [String|Object]], filter : [String|Function])</h3>
<p><code>@afterFilter</code> allows controllers to declare that a function should be run after the action body and all operations have completed during action execution. Functions declared by <code>@afterFilter</code> will thus be run after the code of the action body and also after any redirects or renders have taken place and completed. <code>@beforeFilter</code> optionally accepts some options representing which action(s) to execute the filter before, and then a string naming a function or function proper to execute. See <code>Batman.Controller.beforeFilter</code> for documentation on the structure of the options.

</p>
<div class="console-session">
  <h4>@afterFilter allows declaration of filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TestController = (function(_super) {

    __extends(TestController, _super);

    function TestController() {
      return TestController.__super__.constructor.apply(this, arguments);
    }

    TestController.afterFilter('index', function() {
      return log('after!');
    });

    TestController.prototype.index = function() {
      log('action!');
      return this.render(false);
    };

    return TestController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TestController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged[0]</div><div class="out">'action!'</div><div class="in">logged[1]</div><div class="out">'after!'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@afterFilter filters are executed after renders have completed</h4>
  <pre><code class="javascript"><div class="in">TestController = (function(_super) {

    __extends(TestController, _super);

    function TestController() {
      return TestController.__super__.constructor.apply(this, arguments);
    }

    TestController.afterFilter('index', function() {
      return log('after!');
    });

    TestController.prototype.index = function() {
      log('action!');
      return this.render({
        viewClass: MockView
      });
    };

    return TestController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TestController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged[0]</div><div class="out">'action!'</div><div class="in">logged[1]</div><div class="out">void 0</div><div class="in"></div><div class="out">...</div><div class="in">logged[1]</div><div class="out">'after!'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@afterFilter allows declaration of named filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TodoController = (function(_super) {

    __extends(TodoController, _super);

    function TodoController() {
      return TodoController.__super__.constructor.apply(this, arguments);
    }

    TodoController.afterFilter('create', 'notify');

    TodoController.prototype.create = function() {
      return this.render(false);
    };

    TodoController.prototype.notify = function() {
      return log("Todo created successfully.");
    };

    return TodoController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TodoController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('create')</div><div class="out"></div><div class="in">logged.last</div><div class="out">'Todo created successfully.'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@afterFilter allows whitelisting or blacklisting filters to execute before an action</h4>
  <pre><code class="javascript"><div class="in">TodoController = (function(_super) {

    __extends(TodoController, _super);

    function TodoController() {
      return TodoController.__super__.constructor.apply(this, arguments);
    }

    TodoController.afterFilter({
      only: ['create', 'update']
    }, 'notify');

    TodoController.prototype.index = function() {
      return this.render(false);
    };

    TodoController.prototype.create = function() {
      return this.render(false);
    };

    TodoController.prototype.notify = function() {
      return log("Todo created successfully.");
    };

    return TodoController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TodoController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged.last</div><div class="out">void 0</div><div class="in">controller.dispatch('create')</div><div class="out"></div><div class="in">logged.last</div><div class="out">'Todo created successfully.'</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@afterFilter allows declaration of filters to execute before all actions</h4>
  <pre><code class="javascript"><div class="in">TestController = (function(_super) {

    __extends(TestController, _super);

    function TestController() {
      return TestController.__super__.constructor.apply(this, arguments);
    }

    TestController.afterFilter(function() {
      return log('after!');
    });

    TestController.prototype.index = function() {
      log('action!');
      return this.render(false);
    };

    return TestController;

  })(Batman.Controller)</div><div class="out"></div><div class="in">controller = TestController.get('sharedController')</div><div class="out"></div><div class="in">controller.dispatch('index')</div><div class="out"></div><div class="in">logged[0]</div><div class="out">'action!'</div><div class="in">logged[1]</div><div class="out">'after!'</div></code>
  </pre>
</div>
<h3 id="batman-controller-autoscrolltohash-true">autoScrollToHash[= true] : boolean</h3>
<p><code>autoScrollToHash</code> is a boolean property on the instance level of a controller describing weather or not the controller should automatically scroll the browser window to the element with ID equal to the <code>hash</code> parameter. This behaviour emulates the native behaviour of the same nature, but is implemented in Batman so the functionality works after each dispatch (instead of each page refresh) and when Batman is using hash bang routing. <code>autoScrollToHash</code> is true by default.

</p>
<h3 id="batman-controller-defaultrenderyield-main">defaultRenderYield[= &#39;main&#39;] : String</h3>
<p><code>defaultRenderYield</code> is a <code>String</code> representing which yield a controller should automatically render into if no yield is mentioned explicitly. <code>defaultRenderYield</code> is <code>&#39;main&#39;</code> normally, which means calls to <code>@render()</code> or actions which rely on the implicit rendering render their views into the <code>main</code> yield (and end up where ever <code>data-yield=&quot;main&quot;</code> is found in your HTML).


</p>
<h3 id="batman-controller-controller-actions">Controller Actions</h3>
<h3 id="batman-controller-executeaction">executeAction</h3>
<h3 id="batman-controller-render">render</h3>
<h3 id="batman-controller-redirect">redirect</h3>
<h3 id="batman-controller-scrolltohash">scrollToHash</h3>

<h2 id="batman-model">Batman.Model</h2>
<p><code>Batman.Model</code> is responsible for representing data in your application, and for providing a fluid interface to moving in to and out of your backend.

</p>
<p><em>Note</em>: This documentation uses the term <em>model</em> to refer to the class <code>Model</code> or a <code>Model</code> subclass, and the term <em>record</em> to refer to one instance of <code>Model</code> or of a <code>Model</code> subclass.

</p>
<h3 id="batman-model-the-asynchronous-nature-of-the-world">The Asynchronous Nature of the World</h3>
<p><code>Batman.Model</code>&#39;s operations on both the class and instance level are asynchronous and always will be. This means that the operation functions all accept node style callback functions as the last argument, and only call these callbacks when the operation is complete. Complete in this context means for example with <code>RestStorage</code> only when the entire HTTP response has been received from the server, which can be many seconds after the original call to the operation function.

</p>
<p>These callbacks follow the nodejs convention for their signatures. They should regard the first argument as an error: if it is present, an error has occured, and if it is null or undefined, the operation was successful. Successive arguments represent the result of the operation, or in another world, what would have been returned from the operation function if the operation was synchronous. records returned, a boolean representing status, or response JSON.

</p>
<h3 id="batman-model-the-identity-map">The Identity Map</h3>
<p>Batman uses an identity map when fetching and storing records to do its best to only ever represent a backend record with exactly one client side record. This means that if you use <code>Model.find</code> twice to fetch a record with the same ID, you will get back the same (<code>===</code>) instance in each callback. This is useful because it means that any state the instance might be in is available and preserved no matter which piece of code asked for it, and so that bindings to the instance update no matter which piece of code actually updates the model.

</p>
<p>Practically, the identity map is an implementation detail on Batman&#39;s end and developers shouldn&#39;t have to actually interact with it, but the knowledge that you have the &quot;one true instance&quot; is helpful when reasoning about code and bindings.

</p>
<h3 id="batman-model-subclassing">Subclassing</h3>
<p>Models in your applications should be subclasses of <code>Batman.Model</code>, or subclasses of subclasses, and so on. Extending <code>Batman.Model</code> will give your domain-modeling class all the functionality described here. Subclasses can also be subclassed once more if you so desire. Things like encoders, validations, and storage adapters will be inherited by sub-subclasses.

</p>
<h3 id="batman-model-storage-adapters">Storage Adapters</h3>
<p><code>Batman.Model</code> alone only defines the logic surrounding loading and saving, but not the actual mechanism for doing so. This is left to a <code>Batman.StorageAdaper</code> subclass, 4 of which are included with Batman or in extras:

</p>
<ol>
<li><code>Batman.LocalStorage</code> for storing data in the browsers&#39; <code>localStorage</code>, if available</li>
<li><code>Batman.SessionStorage</code> for storing data in the browser&#39;s <code>sessionStorage</code>, if available.</li>
<li><code>Batman.RestStorage</code> for using HTTP GET, POST, PUT, and DELETE to store data in a backend.</li>
<li><code>Batman.RailsStorage</code> which extends <code>Batman.RestStorage</code> with some handy Rails specific functionality like parsing out validation errors.</li>
</ol>
<h3 id="batman-model-primarykey">@primaryKey : string</h3>
<p><code>primaryKey</code> is a class level configuration option to change which key Batman uses as the primary key. Change the option using <code>set</code>, like so:

</p>
<div class="console-session">
  <h4>primary key can be set using @set</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.set('primaryKey', 'shop_id');

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">Shop.get('primaryKey')</div><div class="out">'shop_id'</div></code>
  </pre>
</div>
<p>The <code>primaryKey</code> is what Batman uses to compare instances to see if they represent the same domain-level object: if two records have the same value at the key specified by <code>primaryKey</code>, only one will be in the identity map. The key specified by <code>primaryKey</code> is also used by the associations system when determining if a record is related to another record, and by the remote storage adapters to generate URLs for records.

</p>
<p>Note_: The default primaryKey is &#39;id&#39;.

</p>
<h3 id="batman-model-storagekey">@storageKey : string</h3>
<p><code>storageKey</code> is a class level option which gives the storage adapters something to interpolate into their specific key generation schemes. In the case of <code>LocalStorage</code> or <code>SessionStorage</code> adapters, the <code>storageKey</code> defines what namespace to store this record under in the <code>localStorage</code> or <code>sessionStorage</code> host objects, and with the case of the <code>RestStorage</code> family of adapters, the <code>storageKey</code> assists in URL generation. See the documentation for the storage adapter of your choice for more information.

</p>
<p>The default <code>storageKey</code> is <code>null</code>.

</p>
<h3 id="batman-model-persist">@persist(mechanism : StorageAdapter) : StorageAdapter</h3>
<p><code>@persist</code> is how a <code>Model</code> subclass is told to persist itself by means of a <code>StorageAdapter</code>. <code>@persist</code> accepts either a <code>StorageAdapter</code> class or instance and will return either the instantiated class or the instance passed to it for further modification.

</p>
<div class="console-session">
  <h4>models can be told to persist via a storage adapter</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.persist(TestStorageAdapter);

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop</div><div class="out"></div><div class="in">record.hasStorage()</div><div class="out">true</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@persist returns the instantiated storage adapter</h4>
  <pre><code class="javascript"><div class="in">adapter = false</div><div class="out"></div><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    adapter = Shop.persist(TestStorageAdapter);

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">adapter instanceof Batman.StorageAdapter</div><div class="out">true</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@persist accepts already instantiated storage adapters</h4>
  <pre><code class="javascript"><div class="in">adapter = new Batman.StorageAdapter</div><div class="out"></div><div class="in">adapter.someHandyConfigurationOption = true</div><div class="out"></div><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.persist(adapter);

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop</div><div class="out"></div><div class="in">record.hasStorage()</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-model-encode">@encode(keys...[, encoderObject : [Object|Function]])</h3>
<p><code>@encode</code> specifies a list of <code>keys</code> a model should expect from and send back to a storage adapter, and any transforms to apply to those attributes as they enter and exit the world of Batman in the optional <code>encoderObject</code>.

</p>
<p>The <code>encoderObject</code> should have an <code>encode</code> and/or a <code>decode</code> key which point to functions. The functions accept the &quot;raw&quot; data (the Batman land value in the case of <code>encode</code>, and the backend land value in the case of <code>decode</code>), and should return the data suitable for the other side of the link. The functions should have the following signatures:

</p>
<pre><code class="coffeescript">encoderObject = {
  encode: (value, key, builtJSON, record) ->
  decode: (value, key, incomingJSON, outgoingObject, record) ->
}</code></pre>
<p>By default these functions are the identity functions. They apply no transformation. The arguments for <code>encode</code> functions are as follows:

</p>
<ul>
<li><code>value</code> is the client side value of the <code>key</code> on the <code>record</code></li>
<li><code>key</code> is the key which the <code>value</code> is stored under on the <code>record</code>. This is useful when passing the same <code>encoderObject</code> which needs to pivot on what key is being encoded to different calls to <code>encode</code>.</li>
<li><code>builtJSON</code> is the object which is modified by each encoder which will eventually be returned by <code>toJSON</code>. To send the server the encoded value under a different key than the <code>key</code>, modify this object by putting the value under the desired key, and return <code>undefined</code>.</li>
<li><code>record</code> is the record on which <code>toJSON</code> has been called.</li>
</ul>
<p>For <code>decode</code> functions:

</p>
<ul>
<li><code>value</code> is the server side value of the <code>key</code> which will end up on the <code>record</code>.</li>
<li><code>key</code> is the key which the <code>value</code> is stored under the incoming JSON.</li>
<li><code>incomingJSON</code> is the JSON which is being decoded into the <code>record</code>. This can be used to create compound key decoders.</li>
<li><code>outgoingObject</code> is the object which is built up by the decoders and then <code>mixin</code>&#39;d to the record.</li>
<li><code>record</code> is the record on which <code>fromJSON</code> has been called.</li>
</ul>
<p>The <code>encode</code> and <code>decode</code> keys can also be false to avoid the default identity function encoder or decoder from being used.

</p>
<p><em>Note</em>: <code>Batman.Model</code> subclasses have no encoders by default, except for one which automatically decodes the <code>primaryKey</code> of the model, which is usually <code>id</code>. To get any data into or out of your model, you must white-list the keys you expect from the server or storage attribute.

</p>
<div class="console-session">
  <h4>@encode accepts a list of keys which are used during decoding</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.encode('name', 'url', 'email', 'country');

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">json = {
    name: "Snowdevil",
    url: "snowdevil.ca"
  }</div><div class="out"></div><div class="in">record = new Shop()</div><div class="out"></div><div class="in">record.fromJSON(json)</div><div class="out"></div><div class="in">record.get('name')</div><div class="out">"Snowdevil"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@encode accepts a list of keys which are used during encoding</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.encode('name', 'url', 'email', 'country');

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop({
    name: "Snowdevil",
    url: "snowdevil.ca"
  })</div><div class="out"></div><div class="in">record.toJSON()</div><div class="out">{
    name: "Snowdevil",
    url: "snowdevil.ca"
  }</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@encode accepts custom encoders</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.encode('name', {
      encode: function(name) {
        return name.toUpperCase();
      }
    });

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop({
    name: "Snowdevil"
  })</div><div class="out"></div><div class="in">record.toJSON()</div><div class="out">{
    name: "SNOWDEVIL"
  }</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@encode accepts custom decoders</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.encode('name', {
      decode: function(name) {
        return name.replace('_', ' ');
      }
    });

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop()</div><div class="out"></div><div class="in">record.fromJSON({
    name: "Snow_devil"
  })</div><div class="out"></div><div class="in">record.get('name')</div><div class="out">"Snow devil"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@encode can be passed an encoderObject with false to prevent the default encoder or decoder</h4>
  <pre><code class="javascript"><div class="in">Shop = (function(_super) {

    __extends(Shop, _super);

    function Shop() {
      return Shop.__super__.constructor.apply(this, arguments);
    }

    Shop.encode('name', {
      encode: false,
      decode: function(x) {
        return x;
      }
    });

    Shop.encode('url');

    return Shop;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Shop()</div><div class="out"></div><div class="in">record.fromJSON({
    name: "Snowdevil",
    url: "snowdevil.ca"
  })</div><div class="out"></div><div class="in">record.get('name')</div><div class="out">'Snowdevil'</div><div class="in">record.get('url')</div><div class="out">"snowdevil.ca"</div><div class="in">record.toJSON()</div><div class="out">{
    url: "snowdevil.ca"
  } // The name key is absent because of encode: false</div></code>
  </pre>
</div>
<p>Some more handy examples:

</p>
<div class="console-session">
  <h4>@encode can be used to turn comma separated values into arrays</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('tags', {
      decode: function(string) {
        return string.split(', ');
      },
      encode: function(array) {
        return array.join(', ');
      }
    });

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Post()</div><div class="out"></div><div class="in">record.fromJSON({
    tags: 'new, hot, cool'
  })</div><div class="out"></div><div class="in">record.get('tags')</div><div class="out">['new', 'hot', 'cool']</div><div class="in">record.toJSON()</div><div class="out">{
    tags: 'new, hot, cool'
  }</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@encode can be used to turn arrays into sets</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('tags', {
      decode: function(array) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args), t = typeof result;
          return t == "object" || t == "function" ? result || child : child;
        })(Batman.Set, array, function(){});
      },
      encode: function(set) {
        return set.toArray();
      }
    });

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">record = new Post()</div><div class="out"></div><div class="in">record.fromJSON({
    tags: ['new', 'hot', 'cool']
  })</div><div class="out"></div><div class="in">record.get('tags') instanceof Batman.Set</div><div class="out">true</div><div class="in">record.toJSON()</div><div class="out">{
    tags: ['new', 'hot', 'cool']
  }</div></code>
  </pre>
</div>
<h3 id="batman-model-validate">@validate(keys...[, options : [Object|Function]])</h3>
<p>Validations allow a model to be marked as <code>valid</code> or <code>invalid</code> based on a set of programmatic rules. By validating a model&#39;s data before it gets to the server we can provide immediate feedback to the user about what they have entered and forgo waiting on a round trip to the server. <code>validate</code> allows the attachment of validations to the model on particular keys, where the validation is either a built in one (invoked by use of options to pass to them) or a custom one (invoked by use of a custom function as the second argument).

</p>
<p><em>Note</em>: Validation in Batman is always asynchronous, despite the fact that none of the validations may use an asynchronous operation to check for validity. This is so that the API is consistent regardless of the validations used.

</p>
<p>Built in validators are attached by calling <code>@validate</code> with options designating how to calculate the validity of the key:

</p>
<div class="console-session">
  <h4>@validate accepts options to check for validity</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.validate('title', 'body', {
      presence: true
    });

    return Post;

  })(Batman.Model)</div><div class="out"></div></code>
  </pre>
</div>
<p>The built in validation options are listed below:

</p>
<ul>
<li><code>presence : boolean</code>: Assert that the string value is existant (not undefined nor null) and has length greather than 0.</li>
<li><code>numeric : true</code>: Assert that the value can be is or can be coerced into a number using <code>parseFloat</code>.</li>
<li><code>greaterThan : number</code>: Assert that the value is greater than the given number.</li>
<li><code>greaterThanOrEqualTo : number</code>: Assert that the value is greater than or equal to the given number.</li>
<li><code>equalTo : number</code>: Assert that the value is equal to the given number.</li>
<li><code>lessThan : number</code>: Assert that the value is less than the given number.</li>
<li><code>lessThanOrEqualTo : number</code>: Assert that the value is less than or equal to the given number.</li>
<li><code>minLength : number</code>: Assert that the value&#39;s <code>length</code> property is greater than the given number.</li>
<li><code>maxLength : number</code>: Assert that the value&#39;s <code>length</code> property is less than the given number.</li>
<li><code>length : number</code>: Assert that the value&#39;s <code>length</code> property is exactly the given number.</li>
<li><code>lengthWithin : [number, number]</code> or <code>lengthIn : [number, number]</code>: Assert that the value&#39;s <code>length</code> property is within the ranger specified by the given array of two numbers, where the first number is the lower bound and the second number is the upper bound.</li>
</ul>
<p>Custom validators should have the signature <code>(errors, record, key, callback)</code>. The arguments are as follows:

</p>
<ul>
<li><code>errors</code>: an <code>ErrorsSet</code> instance which expects to have <code>add</code> called on it to add errors to the model</li>
<li><code>record</code>: the record being validated</li>
<li><code>key</code>: the key to which the validation has been attached</li>
<li><code>callback</code>: a function to call once validation has been complete. Calling this function is ++mandatory++.</li>
</ul>
<p>See <code>Model::validate</code> for information on how to get a particular record&#39;s validity.

</p>
<h3 id="batman-model-loaded">@loaded : Set</h3>
<p>The <code>loaded</code> set is available on every model class and holds every model instance seen by the system in order to function as an identity map. Successful loading or saving individual records or batches of records will result in those records being added to the <code>loaded</code> set. Destroying instances will remove records from the identity set.

</p>
<div class="console-session">
  <h4>the loaded set stores all records seen</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.persist(TestStorageAdapter);

    Post.encode('name');

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">Post.get('loaded') instanceof Batman.Set</div><div class="out">true</div><div class="in">Post.get('loaded.length')</div><div class="out">0</div><div class="in">post = new Post()</div><div class="out"></div><div class="in">post.save()</div><div class="out"></div><div class="in">Post.get('loaded.length')</div><div class="out">1</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>the loaded adds new records caused by loads and removes records caused by destroys</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">adapter = new TestStorageAdapter(Post)</div><div class="out"></div><div class="in">adapter.storage = {
    'posts1': {
      name: "One",
      id: 1
    },
    'posts2': {
      name: "Two",
      id: 2
    }
  }</div><div class="out"></div><div class="in">Post.persist(adapter)</div><div class="out"></div><div class="in">Post.load()</div><div class="out"></div><div class="in">Post.get('loaded.length')</div><div class="out">2</div><div class="in">post = false</div><div class="out"></div><div class="in">Post.find(1, function(err, result) {
    return post = result;
  })</div><div class="out"></div><div class="in">post.destroy()</div><div class="out"></div><div class="in">Post.get('loaded.length')</div><div class="out">1</div></code>
  </pre>
</div>
<h3 id="batman-model-all">@all : Set</h3>
<p>The <code>all</code> set is an alias to the <code>loaded</code> set but with an added implicit <code>load</code> on the model. <code>Model.get(&#39;all&#39;)</code> will synchronously return the <code>loaded</code> set and asynchronously call <code>Model.load()</code> without options to load a batch of records and populate the set originally returned (the <code>loaded</code> set) with the records returned by the server.

</p>
<p><em>Note</em>: The notion of &quot;all the records&quot; is relative only to the client. It completely depends on the storage adapter in use and any backends which they may contact to determine what comes back during a <code>Model.load</code>. This means that if for example your API paginates records, the set found in <code>all</code> may hold on the first 50 records instead of the entire backend set.

</p>
<p><code>all</code> is useful for listing every instance of a model in a view, and since the <code>loaded</code> set will change when the <code>load</code> returns, it can be safely bound to.

</p>
<div class="console-session">
  <h4>the all set asynchronously fetches records when gotten</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">adapter = new AsyncTestStorageAdapter(Post)</div><div class="out"></div><div class="in">adapter.storage = {
    'posts1': {
      name: "One",
      id: 1
    },
    'posts2': {
      name: "Two",
      id: 2
    }
  }</div><div class="out"></div><div class="in">Post.persist(adapter)</div><div class="out"></div><div class="in">Post.get('all.length')</div><div class="out">0 // The synchronously returned set is empty</div><div class="in"></div><div class="out">...</div><div class="in">Post.get('all.length')</div><div class="out">2 // After the async load the set is populated</div></code>
  </pre>
</div>
<h3 id="batman-model-clear">@clear() : Set</h3>
<p><code>Model.clear()</code> empties that <code>Model</code>&#39;s identity map. This is useful for tests and other unnatural situations where records new to the system are guaranteed to be as such.

</p>
<div class="console-session">
  <h4>clearing a model removes all records from the identity map</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">Post.get('loaded.length')</div><div class="out">2</div><div class="in">Post.clear()</div><div class="out"></div><div class="in">Post.get('loaded.length')</div><div class="out">0 // After clear() the loaded set is empty</div></code>
  </pre>
</div>
<h3 id="batman-model-find">@find(id, callback : Function) : Model</h3>
<p><code>Model.find()</code> retrieves a record with the specified <code>id</code> from the storage adapter and calls back with an error if one occurred and the record if one didn&#39;t. <code>find</code> delegates to the storage adapter the <code>Model</code> has been <code>@persist</code>ed with, so it is up to the storage adapter&#39;s semantics to determine what type of errors may return and the timeline on which the callback may be called. The <code>callback</code> is a non-optional function which should adopt the node style callback signature which accepts two arguments, an error, and the record asked for. <code>find</code> returns an &quot;unloaded&quot; record which after the load completes will be populated with the data from the storage adapter.

</p>
<p><em>Note</em>: <code>find</code> gives two results to calling code: one immediately, and one later. <code>find</code> returns a record synchronously as it is called and calls back with a record and importantly these two records are <strong>not</strong> guaranteed to be the same instance. This is because Batman maps the identities of incoming and outgoing records such that there is only ever one canonical instance representing a record, which is useful so bindings are always bound to the same thing. In practice, this means that calling code should use the record <code>find</code> calls back with if anything is going to bind to that object, which is most of the time. The returned record however remains useful for state inspection as well as bookkeeping.

</p>
<div class="console-session">
  <h4>@find calls back the requested model if no error occurs</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    Post.persist(AsyncTestStorageAdapter, {
      storage: {
        'posts2': {
          name: "Two",
          id: 2
        }
      }
    });

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">post = Post.find(2, function(err, result) {
    if (err) {
      throw err;
    }
    return post = result;
  })</div><div class="out"></div><div class="in">post.get('name')</div><div class="out">void 0</div><div class="in"></div><div class="out">...</div><div class="in">post.get('name')</div><div class="out">"Two"</div></code>
  </pre>
</div>
<p><em>Note</em>: <code>find</code> must be passed a callback function. This is for two reasons: calling code must be aware that <code>find</code>&#39;s return value is not necessarily the canonical instance, and calling code must be able to handle errors.

</p>
<div class="console-session">
  <h4>@find calls back with the error if an error occurs</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    Post.persist(AsyncTestStorageAdapter);

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">error = false</div><div class="out"></div><div class="in">post = Post.find(3, function(err, result) {
    return error = err;
  })</div><div class="out"></div><div class="in"></div><div class="out">...</div><div class="in">error instanceof Error</div><div class="out">true</div></code>
  </pre>
</div>
<h3 id="batman-model-load">@load(options = {}, callback : Function)</h3>
<p><code>Model.load()</code> retrieves an array of records according to the given <code>options</code> from the storage adapter and calls back with an error if one occurred and the set of records if one didn&#39;t. <code>load</code> delegates to the storage adapter the <code>Model</code> has been <code>@persist</code>ed with, so it is up to the storage adapter&#39;s semantics to determine what the options do, what kind of errors may arise, and the timeline on which the callback may be called. The <code>callback</code> is a non-optional function which should adopt the node style callback signature which accepts two arguments, an error, and the array of records. <code>load</code> returns undefined.

</p>
<p>For the two main <code>StorageAdapter</code>s Batman provides the <code>options</code> do different things:

</p>
<ul>
<li>For <code>Batman.LocalStorage</code>, the <code>options</code> act as a filter. The adapter will scan all the records in <code>localStorage</code> and return only those records who match all the key/value pairs as given in the options.</li>
<li>For <code>Batman.RestStorage</code>, the <code>options</code> are serialized into query parameters on the <code>GET</code> request.</li>
</ul>
<div class="console-session">
  <h4>@load calls back an array of records retrieved from the storage adapter</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    Post.persist(TestStorageAdapter, {
      storage: {
        'posts1': {
          name: "One",
          id: 1
        },
        'posts2': {
          name: "Two",
          id: 2
        }
      }
    });

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">posts = false</div><div class="out"></div><div class="in">Post.load(function(err, result) {
    if (err) {
      throw err;
    }
    return posts = result;
  })</div><div class="out"></div><div class="in"></div><div class="out">...</div><div class="in">posts.length</div><div class="out">2</div><div class="in">posts[0].get('name')</div><div class="out">"One"</div></code>
  </pre>
</div>
<div class="console-session">
  <h4>@load calls back with an empty array if no records are found</h4>
  <pre><code class="javascript"><div class="in">Post = (function(_super) {

    __extends(Post, _super);

    function Post() {
      return Post.__super__.constructor.apply(this, arguments);
    }

    Post.encode('name');

    Post.persist(TestStorageAdapter);

    return Post;

  })(Batman.Model)</div><div class="out"></div><div class="in">posts = false</div><div class="out"></div><div class="in">Post.load(function(err, result) {
    if (err) {
      throw err;
    }
    return posts = result;
  })</div><div class="out"></div><div class="in"></div><div class="out">...</div><div class="in">posts.length</div><div class="out">0</div></code>
  </pre>
</div>
<h3 id="batman-model-create">@create(attributes = {}, callback) : Model</h3>
<h3 id="batman-model-findorcreate">@findOrCreate(attributes = {}, callback) : Model</h3>
<h3 id="batman-model-id">id : value</h3>
<h3 id="batman-model-dirtykeys">dirtyKeys : Set</h3>
<h3 id="batman-model-errors">errors : ErrorsSet</h3>
<h3 id="batman-model-constructor">constructor(idOrAttributes = {}) : Model</h3>
<h3 id="batman-model-isnew">isNew() : boolean</h3>
<h3 id="batman-model-updateattributes">updateAttributes(attributes) : Model</h3>
<h3 id="batman-model-tostring">toString() : string</h3>
<h3 id="batman-model-tojson">toJSON() : Object</h3>
<h3 id="batman-model-fromjson">fromJSON() : Model</h3>
<h3 id="batman-model-toparam">toParam() : value</h3>
<h3 id="batman-model-state">state() : string</h3>
<h3 id="batman-model-hasstorage">hasStorage() : boolean</h3>
<h3 id="batman-model-load">load(options = {}, callback)</h3>
<h3 id="batman-model-save">save(options = {}, callback)</h3>
<h3 id="batman-model-destroy">destroy(options = {}, callback)</h3>
<h3 id="batman-model-validate">validate(callback)</h3>
<h2 id="batman-validationerror">Batman.ValidationError</h2>
<h2 id="batman-errorsset">Batman.ErrorsSet</h2>



<h2 id="batman-view">Batman.View</h2>

<h3 id="what-are-views">What Are Views?</h3>
<p>The basic flow of interactions with a Batman application is this: a user triggers an event, which dispatches a route, which routes to a controller action, which gets executed, and finally renders a template. The template is an HTML file in the <code>app/views</code> folder with the same name as the action being executed. These templates leverage the power of the Batman view binding system using <code>data-bind</code> and kin to display some data to the user and prompt them for the next event.

</p>
<p>The controller does all this by instantiating a new <code>Batman.View</code>, setting its <code>html</code> property to the contents of the template, and telling the view to <code>render()</code>. When the view&#39;s <code>html</code> property is set, the view inserts it into its <code>node</code>, and when <code>render</code> is called, it traverses that HTML to find and create your bindings. A vanilla <code>Batman.View</code> instance&#39;s <code>render</code> function does this by instantiating a new <code>Batman.Renderer</code> and asking it to do its magic on the view&#39;s <code>html</code>. The view then emits a <code>ready</code> event and then sits around waiting for the user to do something.

</p>
<h4 id="what-are-views-do-more">Do More</h4>
<p><code>Batman.View</code>s have another purpose however: they can be used to create reusable, configurable components which can then be created and reused inside the templates. Examples include a Google Maps component, perhaps a lightbox, a segmented button control, or maybe a class to manage the interactions around flash messages. The flow with these <code>View</code>s is different: they aren&#39;t instantiated by controller, but instead by the template using a <code>data-view</code> binding. They are subclasses of <code>Batman.View</code> which enhance the standard functionality to do something useful. Lets look at some examples of how developers might use <code>data-view</code>:

</p>
<pre><code class="html"><!-- You might want to use a View to make flash messages. This one might apply some CSS styles to make the message clearer to the user, or use some JavaScript to add a close button which hides the div -->
<div data-view="FlashMessageView">Order successfully saved!</div>

<!-- You might want to use a View instead of CSS3 nth-child selectors to apply some styles to round the corners of the first and last list items in this <ul> to make it look like a nice segmented button -->
<ul data-view="SegmentedButtonView">
  <li>Rounded</li>
  <li>Not rounded</li>
  <li>Rounded</li>
</ul>

<!-- Someone who didn't know jQuery might want to implement the placeholder attribute of inputs in a View which might detect if the code is running in a browser which doesn't support placeholder and polyfills the functionality if so -->
<input data-view="PlaceHolderInputView"></input></code></pre>
<p>Each of these doo-dads implements some handy functionality which the template can pull in where ever it likes to spice up the experience. <code>FlashMessageView</code>, <code>SegmentedButtonView</code>, and <code>PlaceHolderInputView</code> are all <code>Batman.View</code> subclasses which have some custom code in them which does cool stuff to whatever node they are applied to. The basic flow for implementation is this:

</p>
<ul>
<li>Create a <code>Batman.View</code> subclass in a namespace where your view can find it</li>
<li>Override the <code>render</code> function to do something useful, while being sure to call <code>super</code></li>
<li>Add useful functions for controlling the views behaviour externally or to be attached as event handlers</li>
<li>Reference the view using a <code>data-view</code> binding on a node elsewhere.</li>
</ul>
<p>Let&#39;s look at how this flow applies to a couple examples.

</p>
<h4 id="what-are-views-an-example">An example: FlashMessageView</h4>
<p><code>FlashMessageView</code> is a <code>View</code> subclass we apply to ephemeral messages meant for display and then dismissal. Let&#39;s say the class has two responsibilities: applying some fun styles to make the whatever node it wraps flash-y, and also adding a close button to the node to let users hide it once they have read the message.

</p>
<p>For demonstration we&#39;ll use jQuery to implement the guts of the view. If we were using only jQuery in this project, we might implement this same functionality by giving our node a unique ID or class, and then using jQuery somewhere to select it and add the classes and close button. With Batman, the selection step is done for us, and all we have to do is apply the functionality. Your <code>Batman.View</code> will receive a <code>node</code> for wrapping which can be found in in the <code>node</code> property on the view instance.

</p>
<pre><code class="coffeescript">class FlashMessageView extends Batman.View
  constructor: ->
    super
    @get('node') #=> DOMElement</code></pre>
<p>So, let&#39;s apply some <code>jQuery</code>s to the node to accomplish the useful stuff. The first idea is to apply these enhancements when the view is created like so:

</p>
<pre><code class="coffeescript">class MyApp.FlashMessageView extends Batman.View
  constructor: ->
    super # process arguments and stuff
    node = $(@get('node'))
    # Add our flash box classes
    node.addClass('flash box warning')

    # Create a button and append it
    button = $("<button>X</button>")
    node.append(button)

    # Tell the button to hide the flash box when it's clicked.
    button.on 'click', ->
      node.hide('fast')</code></pre>
<p>There are a couple things we need to change with this. First, applying the logic in the constructor isn&#39;t the best idea. I deceived you; my apologies. Instead, it should be in the overridden <code>render</code> function on the <code>View</code>, or in a handler on one of the <code>View</code>&#39;s handlers. This is better because, perhaps unbeknownst to you, Batman should be able to instantiate <code>Batman.View</code>s <strong>without a <code>node</code></strong>. The <code>node</code> for a view is not always be available upon construction, so construction, rendering, and insertion are all separate happenings on a <code>View</code>. Depending on what you are doing, your logic should happen before or after one of these stages.

</p>
<h4 id="what-are-views-if-you-want-to-do-something-to-a-views-html-after-rendering-add-a-ready-function-or-listen-to-an-event">If you want to do something to a view&#39;s HTML after rendering, add a <code>ready</code> function, or listen to an event</h4>
<p><code>View</code>s call a function named <code>ready</code> on themselves after all their contents have been rendered and thus their bindings have been setup. This is a useful lifecycle hook to add jQuerys or other fancy logic which implements useful functionality in JavaScript because you know the DOM is setup and stable, at least for now. For example, before the <code>ready</code> event has fired, <code>data-foreach</code> bindings might not have inserted all their items, or <code>data-showif</code> bindings might not have been created and thus their nodes would still be visible.

</p>
<p>Lets move the <code>FlashMessageView</code>&#39;s enhancements to the <code>ready</code> function where they belong:

</p>
<pre><code class="coffeescript">class MyApp.FlashMessageView extends Batman.View

  ready: ->
    node = $(@get('node'))
    # Add our flash box classes
    node.addClass('flash box warning')

    # Create a button and append it
    button = $("<button>X</button>")
    node.append(button)

    # Tell the button to hide the flash box when it's clicked.
    button.on 'click', ->
      node.hide('fast')</code></pre>
<h4 id="what-are-views-if-you-want-to-do-something-to-a-views-html-before-rendering-override-the-render-method">If you want to do something to a view&#39;s HTML before rendering, override the <code>render</code> method.</h4>
<p>For things like adding new nodes with bindings on them or munging the existing source of the given <code>node</code>, put the logic in an overridden <code>render</code> method.

</p>
<p><em>Note</em>: an overridden <code>render</code> function must call super. Calling super is important because the behaviour from the super class still needs to happen. Imagine the flash message had a binding in it:

</p>
<pre><code class="html"><div data-view="FlashMessageView">
  Order #<span data-bind="order.number"> saved successfully!
</div></code></pre>
<p>The super implementation will set up any bindings within the view&#39;s HTML, that is to say the HTML which is within the node where <code>data-view</code> occurs. <code>super</code> also fires the view&#39;s <code>ready</code> event, which is critical.

</p>
<p>So, <code>FlashMessageView</code> could look like this:

</p>
<pre><code class="coffeescript">class MyApp.FlashMessageView extends Batman.View
  render: ->
    node = $(@get('node'))
    # Create a button and append it
    button = $('<button data-event-click="closeFlash">X</button>')
    node.append(button)

    super # Call super last to pass up the return value

  closeFlash: -> $(@get('node')).hide()</code></pre>
<p>We add a button to the element given to this view which has a binding in it. This binding needs to be rendered, so it must be inserted before the super implementation of render gets called. This setup of the view is the &quot;true&quot; Batman way of doing things: using Batman event handlers and bindings to accomplish functionality so the whole setup is uniform, but if using jQuery events like in the example above is easier you should do what you can to ship your code.

</p>
<h4 id="what-are-views-if-you-want-to-do-something-every-time-a-view-is-inserted-or-removed-from-the-dom-use-the-beforeappear-appear-beforedisappear-and-disappear-events">If you want to do something every time a view is inserted or removed from the DOM, use the <code>beforeAppear</code>, <code>appear</code>, <code>beforeDisappear</code>, and <code>disappear</code> events.</h4>
<p>Starting with Batman v0.10.0, Views can be inserted into the DOM and removed again over and over. Neat! This is for performance reasons: rendering a huge template for a controller action over and over can get expensive. Since all the data in the view is inserted using bindings, we can just swap what all the bindings are bound to, and make a few surgical replacements in the DOM instead of doing a whole re-render. What this means for client code however is that views need to be aware that they and enter and exit the DOM more than once, and should be fully functional the whole time.

</p>
<p>If you have something which is conditional on the nodes you are working with being in the DOM, like say, ID selectors, you should attach that stuff in an <code>appear</code> or a <code>beforeDisappear</code> event callback. Use the funky <code>@::on</code> syntax in the class body to attach the handler to the prototype so it will be inherited by all instances of the view.

</p>
<pre><code class="coffeescript">class MyApp.UsedOnceView extends Batman.View
  @::on 'appear', -> document.getElementById('my-cool-element').inDOM = true
  @::on 'beforeDisappear', -> document.getElementById('my-cool-element').inDOM = false</code></pre>
<p>The reason this is necessary is because in the <code>beforeAppear</code> and <code>disappear</code> the View&#39;s node will not be in the DOM. It will be a detached tree, a parentless node, ceased to be accessible via the document, bereft of siblings, resting in only memory, shuffled off &#39;ts mortal tree, run down the curtain and joined the bleedin&#39; choir invisible! Batman detaches <code>View</code>s whenever the tree the <code>View</code>&#39;s node resides in is removed, which often happens if another controller render takes place. Batman will traverse the tree it is removing or inserting and ensure that these events are fired on any views in the tree and not just the root one.


</p>
<h4 id="what-are-views-if-you-want-to-do-something-every-time-a-view-is-removed-for-good-from-the-dom-use-the-beforedestroy-or-destroy-events">If you want to do something every time a view is removed for good from the DOM, use the <code>beforeDestroy</code> or <code>destroy</code> events.</h4>
<p>Along with the view caching and long lived view code introduced in Batman v0.10.0 comes the notion of removal being separate from destruction. If you need to remove state or cleanup any potential memory leaks, use the <code>beforeDestroy</code> or <code>destroy</code> events on a <code>View</code>. <code>beforeDestroy</code> happens while all the bindings are still active, and <code>destroy</code> happens after all bindings have been torn down and any parent <code>View</code>s have been destroyed.

</p>
<p>For example, consider a <code>View</code> which somehow tracks all instances in a global spot:

</p>
<pre><code class="coffeescript">class MyApp.TrackingView extends Batman.View
  @instances: new Batman.SimpleSet
  constructor: ->
    super
    @constructor.instances.add @</code></pre>
<p>This might be a valid strategy to take if you want quick access to all instances of the particular view instead of say traversing the DOM to find them. The issue with this however is that the View instances and thus their entire DOM trees can&#39;t be garbage collected since there will always be a reference to them. To avoid this, we can remove the view from the list of instances when it is destroyed, since we know we no longer need it.

</p>
<pre><code class="coffeescript">class MyApp.TrackingView extends Batman.View
  @instances: new Batman.SimpleSet
  constructor: ->
    super
    @constructor.instances.add @

  @::on 'destroy', -> @constructor.instances.remove @</code></pre>
<h4 id="what-are-views-another-example">Another example: GoogleMapsView</h4>
<p>Lets take a look at another full featured example. <code>GoogleMapsView</code> is a view which will show a map from Google&#39;s Maps API. The biggest difference with this view is that we need to tell the <code>View</code> exactly what area of the Earth to show to the user. It&#39;s functionality relies on being configured: it has to know something more than just the node it should display within.

</p>
<p>One way to do this is by configuring an instance of the <code>GoogleMapsView</code> inside the controller, and then referencing that instance with a <code>data-view</code> binding in the template. For simplicity&#39;s sake we&#39;ll have the view use the static image API from Google Maps which makes things really easy. This API just returns images for a <code>latitude</code> and <code>longitude</code> given a <code>zoom</code>, <code>width</code>, and <code>height</code>. So, we&#39;ll make our <code>View</code> class take those as properties, and then stick them in the <code>src</code> for an <code>&lt;img&gt;</code> tag.

</p>
<pre><code class="coffeescript">class MyApp.GoogleMapsView extends Batman.View
  @accessor 'imageSrc', ->
    "http://maps.googleapis.com/maps/api/staticmap?center=#{@get('latitude')},#{@get('longitude')}&zoom=#{@get('zoom')}&size=#{@get('width')}x#{@get('height')}&sensor=false"

  node: false
  html: """
    <img data-bind-src="imageSrc"
  """</code></pre>
<p>So, when this <code>View</code> subclass is instantiated, it expects to be given <code>latitude</code>, <code>longitude</code>, <code>zoom</code>, <code>width</code>, and <code>height</code> properties like so:

</p>
<pre><code class="coffeescript"># Inside some controller
  @set 'currentMapView', new MyApp.GoogleMapsView
    latitude: 45.429197,
    longitude: -75.690237
    zoom: '...'
    width: '...'
    height: '...'</code></pre>
<p>and then referenced in some template like so:

</p>
<pre><code class="html"><h3>Current Address</h3>
<div data-view="currentMapView"></div></code></pre>
<p>When the <code>&lt;div&gt;</code> above is rendered, the <code>GoogleMapsView</code> will wait for <code>currentAddressView</code> will be called, which will insert the image into the DOM using the configured options. It is important that the <code>View</code> class has the <code>node: false</code> option on its prototype so that it knows it is to wait for a node to be given to it via a <code>data-view</code> binding, instead of auto-generating one like most views rendered by a Controller might.

</p>
<p>In an effort to make the <code>View</code> a more reusable, we should pull out the configuration options from the HTML itself:

</p>
<pre><code class="html"><h3>Current Address</h3>
<div data-view="GoogleMapsView" data-view-latitude="..." data-view-longitude="..." ...></div></code></pre>
<p>and then pull out those configuration options in the view&#39;s logic:

</p>
<pre><code class="coffeescript">class MyApp.GoogleMapsView extends Batman.View
  @option 'latitude', 'longitude', 'zoom', 'width', 'height'
  @accessor 'imageSrc', ->
    "http://maps.googleapis.com/maps/api/staticmap?center=#{@get('latitude')},#{@get('longitude')}&zoom=#{@get('zoom')}&size=#{@get('width')}x#{@get('height')}&sensor=false"</code></pre>
<p>We declare the options that can be passed to the view using <code>data-view-{option}</code> style bindings via the <code>@option</code> class macro on <code>View</code>s. <code>@option</code> creates an property on the view which is accessible throughout the rest of it, so you can do <code>@get(&#39;longitude&#39;)</code> in other places. It then expects to find a <code>data-view-longitude=&quot;-75.690237&quot;</code> on the node the <code>data-view</code> binding occurs on, where the value inside the double quotes can be a filtered keypath like any other. The value at <code>@get(&#39;longitude&#39;)</code> will change as the filtered keypath changes, so we could perhaps bind the <code>longitude</code> option to a <code>customer.longitude</code> keypath by doing the following:

</p>
<pre><code class="html"><h3>Current Address</h3>
<div data-view="GoogleMapsView" data-view-latitude="customer.latitude" data-view-longitude="customer.longitude" ...></div></code></pre>
<p>With the above configuration the image rendered out by the view would change as the customer&#39;s <code>longitude</code> value changed.

</p>
<p><em>Note</em>: <code>data-view</code> bindings accept both <code>View</code> instances and <code>View</code> subclasses. In the first example, <code>data-view</code> referenced an already existing <em>instance</em> of the subclass, and in the second, <code>data-view</code> references the <em>class</em> itself such that it creates its own instance.

</p>
<h4 id="what-are-views-other-stuff">Other Stuff</h4>
<p>A couple notes:

</p>
<ul>
<li>Views can specify their <code>html</code> or <code>source</code> in their class bodies:</li>
</ul>
<pre><code class="coffeescript">class CloseButtonView extends Batman.View
  html: '<button><img src="/images/close.png"></button>'</code></pre>
<ul>
<li>Views can obliterate their node&#39;s contents before rendering with a <code>Batman.DOM.setInnerHTML @get(&#39;node&#39;), &quot;&quot;</code></li>
<li>Views have access to the render context, stored in the <code>context</code> property on the view instance.</li>
</ul>
<pre><code class="coffeescript">class CloseButtonView extends Batman.View
  render: ->
    super
    @set 'something', @context.get('some.key.path')</code></pre>
<p>Be careful using the above strategy for passing <code>View</code>s data: they should be told their data instead of having to fetch it themselves in the interest of being loosely coupled and thus reusable.

</p>
<p>And thats it!
</p>

<h2 id="batman-view-bindings">Batman View Bindings</h2>
<p>Batman&#39;s view bindings are how data gets show and collected from the user. They center on the notion of &quot;bindings&quot;: that the view representation and the JavaScript land value are always guaranteed to be in sync, such that when one changes, the other will reflect it.

</p>
<h3 id="batman-view-bindings-how-to-use-bindings">How to use bindings</h3>
<p>Bindings are declared as attributes on nodes under the <code>data</code> namespace. In practice, it looks like this:

</p>
<pre><code class="html"><div data-bind="name"></div></code></pre>
<p>This instantiates a binding on the <code>div</code> node which will update the node&#39;s <code>innerHTML</code> with the value found at the <code>name</code> keypath in the <a href="#batman-view-bindings-binding-contexts">current context</a>. Whenever the <code>name</code> key changes, the div&#39;s <code>innerHTML</code> will update to the new value.

</p>
<p>Nodes can have multiple bindings like this:

</p>
<pre><code class="html"><p data-bind="body" data-showif="isPublished"></p></code></pre>
<p>or attribute bindings like this:

</p>
<pre><code class="html"><p data-bind-id="currentID"></p></code></pre>
<p>and bindings can be on inputs which the user can change, like this:

</p>
<pre><code class="html"><input type="text" data-bind="title"></input></code></pre>
<p>When the <code>title</code> property changes on the JavaScript object this <code>input</code> is bound to, the <code>input</code>&#39;s value will be updated. When the user types into the <code>input</code> (and <code>change</code> or <code>keyup</code> events are triggered), the <code>title</code> property in JavaScript land will be updated.

</p>
<h3 id="batman-view-bindings-binding-keypaths">Binding Keypaths</h3>
<p>A <code>keypath</code> is the value of the HTML attribute a binding references. Importantly, keypaths can have multiple segments:

</p>
<pre><code class="html"><p data-bind="order.customer.name"></p></code></pre>
<p>The keypath in the above HTML is <code>order.customer.name</code>. When you create a binding to a keypath like this (with dot separating segments), the binding will update the HTML value when <em>any</em> of those segments change. In the above example, this means the <code>p</code> tag&#39;s <code>innerHTML</code> will be updated when:

</p>
<ol>
<li>the order changes,</li>
<li>the order&#39;s customer changes,</li>
<li>or the order&#39;s customer&#39;s name changes.</li>
</ol>
<p>This is important because it means you can rely on a binding to &quot;just work&quot; when anything it depends on changes. If say you had a <code>&lt;select&gt;</code> on the page which changed the <code>order</code>&#39;s <code>customer</code> property, bindings which bind to <code>order.customer.name</code> will update each time you change that select to reflect the new customer&#39;s name.

</p>
<h3 id="batman-view-bindings-binding-contexts">Binding Contexts</h3>
<p>All bindings render in a context. Binding contexts, known internally to Batman as <code>RenderContext</code>s, are objects which emulate the notion of variable scope in JavaScript code. When a controller action renders, it passes a context to the view consisting of itself, the <code>App</code>, and an object with a <code>window</code> key pointing to the host <code>window</code> object.

</p>
<h3 id="batman-view-bindings-keypath-filters">Keypath Filters</h3>
<p>Bindings can bind to filtered keypaths:

</p>
<pre><code class="html"><p data-bind="post.body | truncate 100"></p></code></pre>
<p>The above <code>&lt;p&gt;</code> will have 100 characters worth of the post&#39;s body. Whenever the post&#39;s body changes, it will be retruncated and the <code>&lt;p&gt;</code>&#39;s <code>innerHTML</code> will be updated.

</p>
<p>Filter chains can be arbitrarily long:

</p>
<pre><code class="html"><span data-bind="knight.title | prepend 'Sir' | append ', the honourable'."></span></code></pre>
<p>and filter chains can use other keypaths as arguments to the filters:

</p>
<pre><code class="html"><span data-bind="person.name | prepend ' ' | prepend person.title"></span></code></pre>
<p>The above <code>&lt;span&gt;</code>&#39;s <code>innerHTML</code> will be updated whenever the person&#39;s name, or the person&#39;s title changes.

</p>
<h4 id="batman-view-bindings-keypath-filters-two-way-bindings-and-filters">Two Way Bindings and Filters</h4>
<p>Note that filtered keypaths can not propagate DOM land changes because values can&#39;t always be &quot;unfiltered&quot;. For example, if we bind an input to the truncated version of a string:

</p>
<pre><code class="html"><input data-bind="post.body | truncate 100"></input></code></pre>
<p>The <code>&lt;input&gt;</code>&#39;s value can be updated when the <code>post.body</code> property changes but if a user types into this input field, they will edit the truncated body. If Batman updated the <code>post.body</code> property with the contents of the input, all characters which had been truncated will be lost to the nether. To avoid this loss of information and inconsistency, bindings to filtered keypaths will <em>only update from JavaScript land to HTML</em>, and never vice versa.

</p>
<h3 id="batman-view-bindings-keypath-literals">Keypath Literals</h3>
<p>Keypaths also support a select few literals within them. Numbers, strings, and booleans can be passed as arguments to filters or used as the actual value of the keypath.

</p>
<p>The following are all valid albeit contrived bindings:

</p>
<pre><code class="html"><!-- String literal used as an argument -->
<p data-bind="body | append ' ... '"></p>

<!-- Boolean literal used as an argument -->
<p data-showif="shouldShow | default true"></p>

<!-- Number literal used as an argument -->
<p data-bind="body | truncate 100"></p>

<!-- String literal used as the value -->
<p data-bind="'Hardcoded'"></p>

<!-- Boolean literal used as the value -->
<p data-showif="true"></p></code></pre>
<h3 id="batman-view-bindings-data-bind">data-bind</h3>
<p><code>data-bind</code> creates a two way binding between a property on a <code>Batman.Object</code> and an HTML element. Bindings created via <code>data-bind</code> will update the HTML element with the value of the JS land property as soon as they are created and each time the property changes after, and if the HTML element can be observed for changes, it will update the JS land property with the value from the HTML.

</p>
<p><code>data-bind</code> will change its behaviour depending on what kind of tag it is attached to:

</p>
<ul>
<li><code>&lt;input type=&quot;checkbox&quot;&gt;</code>: the binding will edit the <code>checked</code> property of the checkbox and populate the keypath with a boolean.</li>
<li><code>&lt;input type=&quot;text&quot;&gt;</code> and similar, <code>&lt;textarea</code>&gt;: the binding will edit the <code>value</code> property of the input and populate the keypath with the string found at <code>value</code>.</li>
<li><code>&lt;input type=&quot;file&quot;&gt;</code>: the binding will <em>not</em> edit the <code>value</code> property of the input, but it will update the keypath with a host <code>File</code> object or objects if the node has the <code>multiple</code> attribute.</li>
<li><code>&lt;select&gt;</code>: the binding will edit the <code>selected</code> property of each <code>&lt;option&gt;</code> tag within the <code>&lt;select&gt;</code> match the property at the keypath. If the <code>&lt;select&gt;</code> has the multiple attribute, the value at the keypath can be an array of selected <code>&lt;option&gt;</code> values. You can also use <code>data-bind-selected</code> bindings on the individual options to toggle option selectedness.</li>
<li>All other tags: the binding will edit the <code>innerHTML</code> property of the tag and will not populate the keypath.</li>
</ul>
<p><code>data-bind</code> can also be used to bind an attribute of a node to a JavaScript property. Since attributes can&#39;t be observed for changes, this is a one way binding which will never update the JavaScript land property. Specify which attribute to bind using the &quot;double dash&quot; syntax like so: <code>data-bind-attribute=&quot;some.keypath&quot;</code>. For example, to bind the <code>placeholder</code> attribute of an input, use <code>data-bind-placeholder</code>.

</p>
<pre><code class="html"><input type="text" data-bind-placeholder="'Specify a subtitle for product ' | append product.name"></code></pre>
<p><em>Note</em>: <code>data-bind</code> will not update a JavaScript property if filters are used in the keypath.

</p>
<h3 id="batman-view-bindings-data-source">data-source</h3>
<p><code>data-source</code> creates a one way binding which propagates only changes from JavaScript land to the DOM, and never vice versa. <code>data-source</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will only ever update the DOM and never the JavaScript land property.

</p>
<p>For example, the HTML below will never update the <code>title</code> property on the product, even if the user changes it. Each time the <code>title</code> attribute changes from a <code>set</code> in JavaScript land, the value of the input will be updated to the new value of <code>title</code>, erasing any potential changes that have been made to the value of the input by the user.

</p>
<pre><code class="html"><input type="text" data-source="product.title"></code></pre>
<p><em>Note</em>: <code>data-source-attribute</code> is equivalent to <code>data-bind-attribute</code>, since the former is defined as never making JS land changes, and the latter is unable to.

</p>
<h3 id="batman-view-bindings-data-target">data-target</h3>
<p><code>data-target</code> creates a one way binding which propagates only changes from the DOM to JavaScript land, and never vice versa. <code>data-target</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will never update the DOM even if the JavaScript land value changes.

</p>
<p><em>Note</em>: <code>data-target-attribute</code> is unavailable, because DOM changes to node attributes can&#39;t be monitored.


</p>
<h3 id="batman-view-bindings-data-showif-data-hideif">data-showif / data-hideif</h3>
<p><code>data-showif</code> and <code>data-hideif</code> bind to keypaths and show or hide the node they appear on based on the truthiness of the result. <code>data-showif</code> will show a node if the given keypath evaluates to something truthy, and <code>data-hideif</code> will leave a node visible until its given keypath becomes truthy, at which point the node will be hidden. <code>data-showif</code> and <code>data-hideif</code> show and hide nodes by adding <code>display: none !important;</code> to the node&#39;s <code>style</code> attribute.

</p>
<p>For example, the if the HTML below were rendered where the keypath <code>product.published</code> evaluated to true, the <code>&lt;button&gt;</code> will be visible.

</p>
<pre><code class="html"><button data-showif="product.published">Unpublish Product</button></code></pre>
<p>This is the Batman equivalent of a templating language&#39;s <code>if</code> construct, and  where else branches are implemented using the opposite binding.

</p>
<pre><code class="html"><button data-showif="product.published">Unpublish Product</button>
<button data-hideif="product.published">Publish Product</button></code></pre>
<h3 id="batman-view-bindings-data-addclass-data-removeclass">data-addclass / data-removeclass</h3>
<p><code>data-addclass</code> and <code>data-removeclass</code> bindings can be used to conditionally add or remove a class from a node based on a boolean keypath. Specify the class to add using the &quot;double dash&quot; syntax; for example,<code>data-addclass-big=&quot;some.keypath&quot;</code> on a node will add the &quot;big&quot; class to that node&#39;s classes if <code>some.keypath</code> is truthy. <code>data-removeclass</code> will remove a class (usually one which is present in the HTML) if the keypath passed to it is truthy.

</p>
<p>The outer span in the HTML below will have an &quot;error&quot; class when the <code>product.errors.length</code> keypath evaluates to anything other than 0, since 0 is falsy and other numbers are truthy.

</p>
<pre><code class="html"><span data-addclass-error="product.errors.length">This product has <span data-bind="product.errors.length"></span> errors.</button></code></pre>
<h3 id="batman-view-bindings-data-foreach">data-foreach</h3>
<p><code>data-foreach</code> is used to loop over an iterable object in Batman views. <code>data-foreach</code> duplicates the node it occurs on for each item in the collection found at the keypath given to it, and renders each duplicated node with that node&#39;s object from the collection by putting it in the context under a name passed to it using the &quot;double dash&quot; syntax.

</p>
<p>The <code>&lt;option&gt;</code> node below will be duplicated for each item in the <code>Set</code> at the <code>products</code> keypath.

</p>
<pre><code class="html"><select>
  <option data-foreach-product="products" data-bind="product.name"></option>
</select></code></pre>
<p>Batman will execute the <code>data-foreach</code> binding before the <code>data-bind</code> on the <code>&lt;option&gt;</code> node, which means that the <code>data-bind</code> will be processed for each duplicated node with each separate Product in the <code>products</code> Set in scope for each separate node. If there were say 3 Products in the <code>products</code> set, the HTML would look similar to this once rendered:

</p>
<pre><code class="html"><select>
  <option data-bind="product.name">Product A</option>
  <option data-bind="product.name">Product B</option>
  <option data-bind="product.name">Product C</option>
  <!-- end products -->
</select></code></pre>
<p><code>data-foreach</code> can be used to iterate over <code>Batman.Set</code>s, and most often should be, because it observes any Sets and will update the DOM with new nodes if items are added to the set, or remove nodes from the DOM if their corresponding nodes are removed from the set. <code>data-foreach</code> is, like each other binding, keypath aware, such that if the <code>Set</code> instance at the keypath changes, or any previous segment of the keypath changes, <code>data-foreach</code> will remove all the nodes currently in the DOM, and add new nodes for each new item in the incoming <code>Set</code>.

</p>
<p><em>Note</em>: <code>data-foreach</code> expects to find an iterable object at the keypath given to it, and will emit a warning if it finds <code>undefined</code>.

</p>
<h3 id="batman-view-bindings-data-formfor">data-formfor</h3>
<p><code>data-formfor</code> creates a special addition to the context stack to represent a object under edit within a form. Usually this object is a model. Using the double dash syntax the name for the model to reside under can be specified.

</p>
<h4 id="batman-view-bindings-data-formfor-automatic-validation-display">Automatic Validation Display</h4>
<p><code>data-formfor</code> also has some handy functionality for displaying the result of validating the object under edit in the form. This will only be enabled if the object has an <code>errors</code> Set, which <code>Batman.Models</code> certainly do.

</p>
<p>If a tag matching the relative selector <code>.errors</code> is found, will populate this element with a list of the errors found during validation on the object. The selector for the errors container can be changed by adding a <code>data-errors-list</code> attribute with the value of the selector to the form with the <code>data-formfor</code> binding on it, or editing <code>Batman.DOM.FormBinding::defaultErrorsListSelector</code>.

</p>
<p>If value bindings are made using <code>data-bind</code> to attributes on the model within the form, automatic <code>data-addclass-error</code> bindings will be added to the elements on which the <code>data-bind</code> occurs to add the &quot;error&quot; class when the model has errors on the attribute which <code>data-bind</code> binds to.

</p>
<p>In the HTML below, an automatic <code>data-addclass-error</code> will be added to the <code>&lt;input&gt;</code> which activates when the <code>product</code> model has validation errors on the <code>name</code> attribute.

</p>
<pre><code class="html"><form data-formfor-product="currentProduct">
  <input type="text" data-bind="product.name"></input>
</form></code></pre>
<p>The class which gets automatically added to inputs binding to invalid attributes can be customized by editing <code>Batman.DOM.FormBinding::errorClass</code>.

</p>
<h3 id="batman-view-bindings-data-context">data-context</h3>
<p><code>data-context</code> bindings add the object found at the key to the context stack, optionally under a key using the double dash syntax.

</p>
<p>For example, if a <code>product</code> object exists in the current context, the <code>data-context</code> binding below will expose its attributes at the root level of the context:

</p>
<pre><code class="html"><div data-context="product">
  <span data-bind="name"></span>
  <span data-bind="cost"></span>
</div></code></pre>
<p>Contexts added to the stack can also be scoped under a key using <code>data-context-</code>:

</p>
<pre><code class="html"><div data-context-currentProduct="product">
  <span data-bind="currentProduct"></span>
  <span data-bind="currentProduct"></span>
</div></code></pre>
<p>This is a useful mechanism for passing local variables to partial views.

</p>
<h3 id="batman-view-bindings-data-event">data-event</h3>
<p><code>data-event</code> bindings add DOM event listeners to the nodes they exist on which call the function found at the passed keypath. <code>data-event</code> bindings use the double dash syntax to specify the name of the event to listen for.

</p>
<p>In the HTML below, if the keypath <code>controller.nextAction</code> resolves to a function, that function will be executed each time the <code>&lt;button&gt;</code> element is clicked.

</p>
<pre><code class="html"><button data-event-click="controller.nextAction"></button></code></pre>
<p>Functions which <code>data-event</code> calls will be passed the node and the <code>DOMEvent</code> object: <code>(node, event) -&gt;</code>.

</p>
<p><code>data-event</code> supports the following types of events formally and should &quot;do the right thing&quot; when attached to elements which fire these events:

</p>
<ul>
<li>click</li>
<li>doubleclick</li>
<li>change</li>
<li>submit</li>
</ul>
<p>If the event name used doesn&#39;t match the above events, the event name used will just fall through and be passed to <code>window.addEventListener</code>.

</p>
<h3 id="batman-view-bindings-data-route">data-route</h3>
<p><code>data-route</code> bindings are used to dispatch a new controller action upon the clicking of the node they bind to. <code>data-route</code> expects to find either a string or a <code>NamedRouteQuery</code> at the keypath passed to it. With this route, it will add an event handler to the <code>click</code> action of the element which dispatches the route and prevents the default action of the DOMEvent. <code>data-route</code> will also populate the <code>href</code> attribute if it occurs on an <code>&lt;a&gt;</code> tag so that other functons like &quot;Copy Link Address&quot; and Alt+Click continue to work on the link.

</p>
<p>The first way to use <code>data-route</code> are by passing it a string, which can be built using filters or an accessor, but the preferred way is to use the <code>NamedRouteQuery</code>. These objects are generated for you by starting keypaths at the <code>App.routes</code> property. All <code>Batman.App</code>s have a <code>routes</code> property which holds a nested list of all the routes, which you descend into by passing various key segments and objects. Since the <code>App</code> object is present in the default context stack, <code>data-route</code> keypaths can just start with <code>routes</code> like so.

</p>
<p>For example, assume the following routes definition in the current <code>Batman.App</code>:

</p>
<pre><code class="coffeescript">class Alfred extends Batman.App
  @resources 'todos'</code></pre>
<p>This means that routes like <code>/todos</code> and <code>/todos/:id</code> exist. To route to the collection action, use the plural name of the resource:

</p>
<pre><code class="html"><a data-route="routes.todos"></a></code></pre>
<p>To route to an individual todo things get a bit more complicated. If we have a Todo model with ID# <code>42</code> in the context as <code>todo</code>, use the <code>get</code> filter shorthand on the <code>NamedRouteQuery</code> returned by <code>routes.todos</code> to generate a member route:

</p>
<pre><code class="html"><a data-route="routes.todos[todo]"></a></code></pre>
<p>Underneath this is doing <code>Alfred.get(&#39;routes.todos&#39;).get(todo)</code>; that is to say the todo object is being passed as a key to the <code>NamedRouteQuery</code>, which knows how to generate a member route when given a record. The above HTML when rendered will look like this:

</p>
<pre><code class="html"><a data-route="routes.todos[todo]" href="/todos/42"></a></code></pre>
<p>This syntax can be extended to nested routes. If we have nested routes, we can use chained gets to generated nested routes

</p>
<pre><code class="coffeescript">class Tracker extends Batman.App
  @resources 'villians', ->
    @resources 'crimes'</code></pre>
<p>Routes for collection and member crimes should look like <code>/villians/:villian_id/crimes</code> and <code>/villians/:villian_id/crimes/:id</code> respectively. Assuming the presence of a <code>villian</code> and a <code>crime</code> in the context, chained <code>get</code>s on <code>NamedRouteQuery</code>s achieve this:

</p>
<pre><code class="html"><!-- Collection of crimes for a particular villian -->
<a data-route="routes.villians[villian].crimes"></a>
<!-- One crime of a particular villian -->
<a data-route="routes.villians[villian].crimes[crime]"></a></code></pre>
<p><em>Note</em>: <code>data-route</code> bindings route only to internal dispatch, and not external links. Use a regular <code>&lt;a&gt;</code> tag to link away from the application.

</p>
<h3 id="batman-view-bindings-data-view">data-view</h3>
<p><code>data-view</code> bindings attach custom <code>Batman.View</code> instances or instantiate custom <code>View</code> subclasses to / on a node. <code>data-view</code> expects either a <code>Batman.View</code> instance or subclass at the keypath passed to it. If an instance is passed, it will <code>set</code> the <code>node</code> property of the view to the node the <code>data-view</code> occurs on. If a class is passed, that class will be instantiated with the context the <code>data-view</code> binding executed in and with the node it occurred upon. See <code>Batman.View</code> for more information on custom Views and their uses.

</p>
<p><em>Note</em>: <code>data-view</code> bindings will bind to the passed keypath until it exists, that is to say until the value of it is not <code>undefined</code>. After the <code>View</code> has been set up, the <code>data-view</code> binding will remove itself and stop observing the keypath.

</p>
<h3 id="batman-view-bindings-data-partial">data-partial</h3>
<p><code>data-partial</code> pulls in a partial template and renders it in the current context of the node the <code>data-partial</code> occurs in. <code>data-partial</code> expects the name of the view to render in the value of the HTML attribute. <strong>Warning</strong>: This value is not a keypath. The HTML attribute&#39;s value is interpreted as a string, and the template which resides at that view path will be rendered.

</p>
<p>If we have this HTML at <code>views/villains/_stub.html</code> in our app:

</p>
<pre><code class="html"><span data-bind="villian.name"></span></code></pre>
<p>and in <code>views/villians/show.html</code> we have this HTML:

</p>
<pre><code class="html"><h1>A villian!</h1>
<div data-partial="villians/_stub"></div></code></pre>
<p>the contents of the <code>stub</code> partial will be inserted and rendered in the <code>&lt;div&gt;</code> above.

</p>
<h3 id="batman-view-bindings-data-mixin">data-mixin</h3>
<h3 id="batman-view-bindings-data-defineview">data-defineview</h3>
<h3 id="batman-view-bindings-data-renderif">data-renderif</h3>
<h3 id="batman-view-bindings-data-yield">data-yield</h3>
<h3 id="batman-view-bindings-data-contentfor">data-contentfor</h3>
<h3 id="batman-view-bindings-data-replace">data-replace</h3>
<h2 id="batman-view-filters">Batman View Filters</h2>
<h3 id="batman-view-filters-raw">raw(value) : string</h3>
<p>The <code>raw</code> filter renders the value unescaped.

</p>
<pre><code class="html"><span data-bind="someHTMLyString | raw"></span></code></pre>
<h3 id="batman-view-filters-get">get(value, key) : value</h3>
<h3 id="batman-view-filters-valuekey">value[key] : value</h3>
<p>Shorthand for the <code>get</code> filter.

</p>
<h3 id="batman-view-filters-equals">equals(left, right) : boolean</h3>
<h3 id="batman-view-filters-not">not(value) : boolean</h3>
<h3 id="batman-view-filters-matches">matches(value, string) : boolean</h3>
<h3 id="batman-view-filters-truncate">truncate(value, length, end = &#39;...&#39;) : string</h3>
<h3 id="batman-view-filters-default">default(value, defaultValue) : value</h3>
<h3 id="batman-view-filters-prepend">prepend(value, string) : string</h3>
<h3 id="batman-view-filters-append">append(value, string) : string</h3>
<h3 id="batman-view-filters-replace">replace(value, searchString, replaceString[, flags]) : string</h3>
<h3 id="batman-view-filters-downcase">downcase(value) : string</h3>
<h3 id="batman-view-filters-upcase">upcase(value) : string</h3>
<h3 id="batman-view-filters-pluralize">pluralize(value, count) : string</h3>
<h3 id="batman-view-filters-humanize">humanize(string) : string</h3>
<h3 id="batman-view-filters-join">join(value, separator = &#39;&#39;) : string</h3>
<h3 id="batman-view-filters-sort">sort(value) : value</h3>
<h3 id="batman-view-filters-map">map(iterable) : value</h3>
<h3 id="batman-view-filters-has">has(iterable, item) : boolean</h3>
<h3 id="batman-view-filters-first">first(iterable) : value</h3>
<h3 id="batman-view-filters-meta">meta(value, keypath) : value</h3>
<h3 id="batman-view-filters-interpolate">interpolate(string, valuesObject) : string</h3>
<h3 id="batman-view-filters-witharguments">withArguments(function, curriedArguments...) : function</h3>
<h3 id="batman-view-filters-routetoaction">routeToAction(model, action) : string</h3>
<h3 id="batman-view-filters-escape">escape(value) : string</h3>



    </div><!-- /.content -->


  </div><!-- /.container -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="js/libs/jquery.min.js"><\/script>')</script> 
  <script src="js/quicksearch.jquery.js"></script> 
  <script src="js/docs.js"></script>

</body>
</html>
